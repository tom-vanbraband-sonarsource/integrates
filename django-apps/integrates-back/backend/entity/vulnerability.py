""" GraphQL Entity for Vulnerability  """
# pylint: disable=no-self-use

from typing import Iterable, List as _List, cast
from django.core.files.uploadedfile import (
    InMemoryUploadedFile, TemporaryUploadedFile
)
from graphene import Argument, String, ObjectType, Boolean, Mutation, List, Enum, Int
from graphene.types.generic import GenericScalar
from graphene_file_upload.scalars import Upload
from magic import Magic

from backend.decorators import (
    require_login, require_finding_access, enforce_authz
)
from backend.domain import finding as finding_domain
from backend.domain.vulnerability import (
    delete_tags, delete_vulnerability,
    process_file, update_all_pending_vulns, update_approval_status,
    update_last_vuln_date, update_treatments, request_verification,
    verify_vulnerabilities
)
from backend.domain.project import (
    get_finding_project_name
)
from backend.services import is_customeradmin

from backend import util
from backend.exceptions import (
    ErrorUploadingFileS3, InvalidFileSize,
    InvalidFileType, InvalidSeverity
)


class Vulnerability(ObjectType):
    """Vulnerability Class."""

    id = String()  # noqa pylint: disable=invalid-name
    analyst = String()
    finding_id = String()
    vuln_type = String()
    where = String()
    specific = String()
    historic_state = List(GenericScalar)
    current_state = String()
    current_approval_status = String()
    last_analyst = String()
    last_approved_status = String()
    acceptance_date = String()
    treatment = String()
    external_bts = String()
    treatment_justification = String()
    treatment_manager = String()
    severity = String()
    tag = String()
    tags = List(String)
    remediated = Boolean()
    verification = String()

    def __getitem__(self, key: str) -> str:
        if key == 'UUID':
            key = 'id'
        return getattr(self, key)

    def resolve_acceptance_date(self, info: object) -> String:
        """Resolve Acceptance Date"""
        del info
        return self.acceptance_date

    def resolve_treatment_manager(self, info: object) -> String:
        """Resolve Treatment Manager"""
        del info
        return self.treatment_manager

    def resolve_treatment_justification(self, info: object) -> String:
        """Resolve Treatment Justification"""
        del info
        return self.treatment_justification

    def resolve_external_bts(self, info: object) -> String:
        """Resolve External Bts"""
        del info
        return self.external_bts

    def resolve_id(self, info: object) -> String:
        """Resolve id attribute."""
        del info
        return self.id

    def resolve_treatment(self, info: object) -> String:
        """Resolve treatment attribute."""
        del info
        return self.treatment

    def resolve_finding_id(self, info: object) -> String:
        """Resolve vulnerabilities attribute."""
        del info
        return self.finding_id

    def resolve_vuln_type(self, info: object) -> String:
        """Resolve vulnerabilities attribute."""
        del info
        return self.vuln_type

    def resolve_where(self, info: object) -> String:
        """Resolve vulnerabilities attribute."""
        del info
        return self.where

    def resolve_specific(self, info: object) -> String:
        """Resolve vulnerabilities attribute."""
        del info
        return self.specific

    def resolve_historic_state(self, info: object) -> List:
        """Resolve vulnerabilities attribute."""
        del info
        return self.historic_state

    def resolve_current_state(self, info: object) -> String:
        """Resolve vulnerabilities attribute."""
        del info
        return self.current_state

    def resolve_severity(self, info: object) -> String:
        """Resolve vulnerabilities attribute."""
        del info
        return self.severity

    def resolve_tag(self, info: object) -> str:
        """Resolve vulnerabilities attribute."""
        del info
        return ', '.join(cast(Iterable[str], self.tags))

    def resolve_current_approval_status(self, info: object) -> String:
        """Resolve vulnerabilities attribute."""
        del info
        return self.current_approval_status

    def resolve_last_approved_status(self, info: object) -> String:
        """Resolve vulnerabilities attribute."""
        del info
        return self.last_approved_status

    @enforce_authz
    def resolve_last_analyst(self, info: object) -> String:
        """ Resolve last approved analyst attribute """
        del info
        return self.last_analyst

    @enforce_authz
    def resolve_analyst(self, info: object) -> String:
        """ Resolve analyst attribute """
        del info
        return self.analyst

    def resolve_remediated(self, info: object) -> Boolean:
        """Resolve vulnerabilities attribute."""
        del info
        return self.remediated

    def resolve_verification(self, info: object) -> String:
        """Resolve vulnerabilities attribute."""
        del info
        return self.verification


class ApproveVulnerability(Mutation):
    """Approve a vulnerability."""

    class Arguments():
        """Arguments of the class."""
        uuid = String()
        finding_id = String(required=True)
        approval_status = Boolean(required=True)

    success = Boolean()

    @require_login
    @enforce_authz
    @require_finding_access
    def mutate(self, info, finding_id: str, approval_status: str, uuid: str = '') -> object:
        project_name = get_finding_project_name(finding_id)
        success = False
        if uuid:
            success = update_approval_status(
                finding_id, uuid, approval_status)
        else:
            success = update_all_pending_vulns(finding_id, approval_status)
        if success:
            util.invalidate_cache(finding_id)
            util.invalidate_cache(project_name)
            util.cloudwatch_log(
                info.context, 'Security: Approve vulnerability from {project}\
                    project succesfully'.format(
                    project=project_name))
        else:
            util.cloudwatch_log(info.context, 'Security: Attempted to approve\
                vulnerability from {project} project'.format(
                project=project_name))

        ret = ApproveVulnerability(success=success)
        return ret


class DeleteTags(Mutation):
    """Delete tags of vulnerabilitities"""

    class Arguments():
        finding_id = String(required=True)
        vulnerabilities = List(String, required=True)
    success = Boolean()

    @staticmethod
    @require_login
    @enforce_authz
    @require_finding_access
    def mutate(_, info, finding_id: str, vulnerabilities: List) -> object:
        project_name = get_finding_project_name(finding_id)
        success = delete_tags(finding_id, cast(_List[str], vulnerabilities))
        if success:
            util.invalidate_cache(finding_id)
            util.invalidate_cache(project_name)
            util.cloudwatch_log(
                info.context, f'Delete tags from {finding_id}')

        return DeleteTags(success=success)


class UpdateTreatmentVuln(Mutation):
    """Update treatment info in vulnerabilites"""

    class Arguments():
        """Arguments of the class."""
        acceptance_date = String()
        bts_url = String()
        finding_id = String(required=True)
        treatment = String()
        treatment_manager = String()
        treatment_justification = String()
        vulnerabilities = List(String, required=True)
        severity = Int()
        tag = String()
    success = Boolean()

    @require_login
    @enforce_authz
    @require_finding_access
    def mutate(self, info, **parameters):
        """update vulnerabilities in database."""
        min_value = 0
        max_value = 1000000000
        vulnerabilities = parameters.get('vulnerabilities')
        finding_id = parameters.get('finding_id')
        if parameters.get('severity') and parameters.get('severity') != -1:
            if min_value > parameters.get('severity') or \
               parameters.get('severity') > max_value:
                raise InvalidSeverity([min_value, max_value])
        user_data = util.get_jwt_content(info.context)
        project_name = finding_domain.get_finding(finding_id)['projectName']
        is_customer_admin = is_customeradmin(project_name, user_data['user_email'])
        result_update_vuln = update_treatments(vulnerabilities, finding_id,
                                               parameters, info, is_customer_admin)
        if result_update_vuln:
            util.invalidate_cache(finding_id)
        result = UpdateTreatmentVuln(success=result_update_vuln)
        return result


class DeleteVulnerability(Mutation):
    """Delete a vulnerability."""

    class Arguments():
        """Arguments of the class."""

        id = String(required=True)  # noqa pylint: disable=invalid-name
        finding_id = String(required=True)
        justification = Argument(
            Enum('DeleteVulnerabilityJustification', [
                ('DUPLICATED', 'DUPLICATED'),
                ('FALSE_POSITIVE', 'FALSE_POSITIVE'),
                ('REPORTING_ERROR', 'REPORTING_ERROR')]), required=True)

    success = Boolean()

    @require_login
    @enforce_authz
    @require_finding_access
    def mutate(self, info, **kwargs):
        """Delete vulnerability from database."""
        finding_id = kwargs.get('finding_id')
        uuid = kwargs.get('id')
        justification = kwargs.get('justification')
        project = get_finding_project_name(finding_id)
        user_email = util.get_jwt_content(info.context)['user_email']
        success = delete_vulnerability(
            finding_id, uuid, justification, user_email)

        if success:
            util.invalidate_cache(finding_id)
            util.invalidate_cache(project)
            util.cloudwatch_log(
                info.context, f'Security: Deleted vulnerability: {uuid} '
                f'from {project} project succesfully')
        else:
            util.cloudwatch_log(
                info.context, 'Security: Attempted to delete vulnerability: '
                f'{uuid} from {project} project')
        ret = DeleteVulnerability(success=success)
        return ret


class UploadFile(Mutation):
    """Upload a file with the vulnerabilities."""

    class Arguments():
        """Arguments of the class."""
        file = Upload(required=True)
        finding_id = String(required=True)
        origin = String(required=False)
    success = Boolean()

    @require_login
    @enforce_authz
    @require_finding_access
    def mutate(self, info, **kwargs):
        """Process file input."""
        finding_id = kwargs.get('finding_id')
        origin = kwargs.get('origin', '')
        project = finding_domain.get_project(finding_id)
        file_input = info.context.FILES['1']
        mime = Magic(mime=True)
        if isinstance(file_input, TemporaryUploadedFile):
            mime_type = mime.from_file(file_input.temporary_file_path())
        elif isinstance(file_input, InMemoryUploadedFile):
            mime_type = mime.from_buffer(file_input.file.getvalue())
        else:
            mime_type = ''
        mib = 1048576
        if (file_input and
                mime_type in ['text/x-yaml', 'text/plain', 'text/html']):
            if file_input.size < 1 * mib:
                success = process_file(file_input, finding_id, info, origin)
            else:
                raise InvalidFileSize()
        else:
            raise InvalidFileType()
        ret = UploadFile(success=success)
        if success:
            update_last_vuln_date(finding_id)
            util.invalidate_cache(finding_id)
            util.invalidate_cache(project)
            util.cloudwatch_log(info.context, 'Security: Uploaded file in {project} \
                project succesfully'.format(project=project))
        else:
            util.cloudwatch_log(info.context, 'Security: Attempted to delete file \
                from {project} project'.format(project=project))
            raise ErrorUploadingFileS3()
        return ret


class RequestVerificationVuln(Mutation):
    """ Request verification """
    class Arguments():
        finding_id = String(required=True)
        justification = String(required=True)
        vulnerabilities = List(String, required=True)
    success = Boolean()

    @require_login
    @enforce_authz
    @require_finding_access
    def mutate(self,
               info, finding_id: str, justification: str, vulnerabilities: List) -> object:
        project_name = get_finding_project_name(finding_id)
        user_info = util.get_jwt_content(info.context)
        success = request_verification(
            finding_id,
            user_info['user_email'],
            str.join(' ', [user_info.get('first_name', ''), user_info.get('last_name', '')]),
            justification,
            cast(_List[str], vulnerabilities)
        )
        if success:
            util.invalidate_cache(finding_id)
            util.invalidate_cache(project_name)
            util.cloudwatch_log(info.context, 'Security: Verified a request '
                                f'in finding_id: {finding_id}')
        return RequestVerificationVuln(success=success)


class VerifyRequestVuln(Mutation):
    """ Verify request """
    class Arguments():
        finding_id = String(required=True)
        justification = String(required=True)
        open_vulns = List(String, required=True)
        closed_vulns = List(String, required=True)
    success = Boolean()

    @require_login
    @enforce_authz
    @require_finding_access
    def mutate(self, info, **parameters):
        finding_id = parameters.get('finding_id')
        project_name = get_finding_project_name(finding_id)
        user_info = util.get_jwt_content(info.context)
        success = verify_vulnerabilities(
            finding_id,
            user_info['user_email'],
            str.join(' ', [user_info.get('first_name', ''), user_info.get('last_name', '')]),
            info,
            parameters
        )
        if success:
            util.invalidate_cache(finding_id)
            util.invalidate_cache(project_name)
            util.cloudwatch_log(info.context, 'Security: Verified a request '
                                f'in finding_id: {finding_id}')
        return VerifyRequestVuln(success=success)
