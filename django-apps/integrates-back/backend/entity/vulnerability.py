""" GraphQL Entity for Vulnerability  """
# pylint: disable=no-self-use
import html
import os
import uuid as _uuid
from datetime import datetime

import yaml
from django.core.files.uploadedfile import (
    InMemoryUploadedFile, TemporaryUploadedFile
)
from graphene import Argument, String, ObjectType, Boolean, Mutation, List, Enum, Int
from graphene.types.generic import GenericScalar
from graphene_file_upload.scalars import Upload
from magic import Magic
from pykwalify.core import Core
from pykwalify.errors import CoreError, SchemaError

from backend.decorators import require_login, require_role, require_finding_access
from backend.domain import finding as finding_domain
from backend.domain.vulnerability import (
    is_range, is_secuence, ungroup_specific, add_vuln_to_dynamo,
    delete_vulnerability, update_all_pending_vulns, update_approval_status,
    update_treatments
)
from backend.domain.project import (
    get_finding_project_name
)
from backend.services import is_customeradmin

from backend import util
from backend.exceptions import (
    InvalidSchema, InvalidFileSize, InvalidFileType, InvalidPort,
    InvalidPath, InvalidSeverity, InvalidSpecific
)
from backend.dal import integrates_dal


class Vulnerability(ObjectType):
    """Vulnerability Class."""

    id = String()  # noqa pylint: disable=invalid-name
    analyst = String()
    finding_id = String()
    vuln_type = String()
    where = String()
    specific = String()
    historic_state = List(GenericScalar)
    current_state = String()
    current_approval_status = String()
    last_analyst = String()
    last_approved_status = String()
    acceptance_date = String()
    treatment = String()
    external_bts = String()
    treatment_justification = String()
    treatment_manager = String()
    severity = String()
    tag = String()
    tags = List(String)

    def __getitem__(self, key):
        if key == 'UUID':
            key = 'id'
        return getattr(self, key)

    def resolve_acceptance_date(self, info):
        """Resolve Acceptance Date"""
        del info
        return self.acceptance_date

    def resolve_treatment_manager(self, info):
        """Resolve Treatment Manager"""
        del info
        return self.treatment_manager

    def resolve_treatment_justification(self, info):
        """Resolve Treatment Justification"""
        del info
        return self.treatment_justification

    def resolve_external_bts(self, info):
        """Resolve External Bts"""
        del info
        return self.external_bts

    def resolve_id(self, info):
        """Resolve id attribute."""
        del info
        return self.id

    def resolve_treatment(self, info):
        """Resolve treatment attribute."""
        del info
        return self.treatment

    def resolve_finding_id(self, info):
        """Resolve vulnerabilities attribute."""
        del info
        return self.finding_id

    def resolve_vuln_type(self, info):
        """Resolve vulnerabilities attribute."""
        del info
        return self.vuln_type

    def resolve_where(self, info):
        """Resolve vulnerabilities attribute."""
        del info
        return self.where

    def resolve_specific(self, info):
        """Resolve vulnerabilities attribute."""
        del info
        return self.specific

    def resolve_historic_state(self, info):
        """Resolve vulnerabilities attribute."""
        del info
        return self.historic_state

    def resolve_current_state(self, info):
        """Resolve vulnerabilities attribute."""
        del info
        return self.current_state

    def resolve_severity(self, info):
        """Resolve vulnerabilities attribute."""
        del info
        return self.severity

    def resolve_tag(self, info):
        """Resolve vulnerabilities attribute."""
        del info
        return ', '.join(self.tags)

    def resolve_current_approval_status(self, info):
        """Resolve vulnerabilities attribute."""
        del info
        return self.current_approval_status

    def resolve_last_approved_status(self, info):
        """Resolve vulnerabilities attribute."""
        del info
        return self.last_approved_status

    @require_role(['analyst', 'admin'])
    def resolve_last_analyst(self, info):
        """ Resolve last approved analyst attribute """
        del info
        return self.last_analyst

    @require_role(['analyst', 'admin'])
    def resolve_analyst(self, info):
        """ Resolve analyst attribute """
        del info
        return self.analyst


class ApproveVulnerability(Mutation):
    """Approve a vulnerability."""

    class Arguments():
        """Arguments of the class."""
        uuid = String()
        finding_id = String(required=True)
        approval_status = Boolean(required=True)

    success = Boolean()

    @require_login
    @require_role(['analyst', 'admin'])
    @require_finding_access
    def mutate(self, info, finding_id, approval_status, uuid=''):
        project_name = get_finding_project_name(finding_id)
        success = False
        if uuid:
            success = update_approval_status(
                finding_id, uuid, approval_status)
        else:
            success = update_all_pending_vulns(finding_id, approval_status)
        if success:
            util.invalidate_cache(finding_id)
            util.invalidate_cache(project_name)
            util.cloudwatch_log(
                info.context, 'Security: Approve vulnerability from {project}\
                    project succesfully'.format(
                    project=project_name))
        else:
            util.cloudwatch_log(info.context, 'Security: Attempted to approve\
                vulnerability from {project} project'.format(
                project=project_name))

        ret = ApproveVulnerability(success=success)
        return ret


class UpdateTreatmentVuln(Mutation):
    """Update treatment info in vulnerabilites"""

    class Arguments():
        """Arguments of the class."""
        acceptance_date = String()
        bts_url = String()
        finding_id = String(required=True)
        treatment = String()
        treatment_manager = String()
        treatment_justification = String()
        vulnerabilities = List(String, required=True)
        severity = Int()
        tag = String()
    success = Boolean()

    @require_login
    @require_role(['customer', 'admin'])
    @require_finding_access
    def mutate(self, info, **parameters):
        """update vulnerabilities in database."""
        min_value = 0
        max_value = 1000000000
        vulnerabilities = parameters.get('vulnerabilities')
        finding_id = parameters.get('finding_id')
        if parameters.get('severity') and parameters.get('severity') != -1:
            if min_value > parameters.get('severity') or \
               parameters.get('severity') > max_value:
                raise InvalidSeverity([min_value, max_value])
        user_data = util.get_jwt_content(info.context)
        project_name = finding_domain.get_finding(finding_id)['projectName']
        is_customer_admin = is_customeradmin(project_name, user_data['user_email'])
        result_update_vuln = update_treatments(vulnerabilities, finding_id,
                                               parameters, info, is_customer_admin)
        if result_update_vuln:
            util.invalidate_cache(finding_id)
        result = UpdateTreatmentVuln(success=result_update_vuln)
        return result


class DeleteVulnerability(Mutation):
    """Delete a vulnerability."""

    class Arguments():
        """Arguments of the class."""

        id = String(required=True)  # noqa pylint: disable=invalid-name
        finding_id = String(required=True)
        justification = Argument(
            Enum('DeleteVulnerabilityJustification', [
                ('DUPLICATED', 'DUPLICATED'),
                ('FALSE_POSITIVE', 'FALSE_POSITIVE'),
                ('REPORTING_ERROR', 'REPORTING_ERROR')]), required=True)

    success = Boolean()

    @require_login
    @require_role(['analyst', 'admin'])
    @require_finding_access
    def mutate(self, info, **kwargs):
        """Delete vulnerability from database."""
        finding_id = kwargs.get('finding_id')
        uuid = kwargs.get('id')
        justification = kwargs.get('justification')
        project = get_finding_project_name(finding_id)
        user_email = util.get_jwt_content(info.context)['user_email']
        success = delete_vulnerability(
            finding_id, uuid, justification, user_email)

        if success:
            util.invalidate_cache(finding_id)
            util.invalidate_cache(project)
            util.cloudwatch_log(
                info.context, f'Security: Deleted vulnerability: {uuid} '
                f'from {project} project succesfully')
        else:
            util.cloudwatch_log(
                info.context, 'Security: Attempted to delete vulnerability: '
                f'{uuid} from {project} project')
        ret = DeleteVulnerability(success=success)
        return ret


class UploadFile(Mutation):
    """Upload a file with the vulnerabilities."""

    class Arguments():
        """Arguments of the class."""
        file = Upload(required=True)
        finding_id = String(required=True)
        origin = String(required=False)
    success = Boolean()

    @require_login
    @require_role(['analyst', 'admin'])
    @require_finding_access
    def mutate(self, info, **kwargs):
        """Process file input."""
        finding_id = kwargs.get('finding_id')
        origin = kwargs.get('origin', '')
        project = integrates_dal.get_finding_project(finding_id)
        file_input = info.context.FILES['1']
        mime = Magic(mime=True)
        if isinstance(file_input, TemporaryUploadedFile):
            mime_type = mime.from_file(file_input.temporary_file_path())
        elif isinstance(file_input, InMemoryUploadedFile):
            mime_type = mime.from_buffer(file_input.file.getvalue())
        else:
            mime_type = ''
        mib = 1048576
        if (file_input and
                mime_type in ['text/x-yaml', 'text/plain', 'text/html']):
            if file_input.size < 1 * mib:
                success = process_file(file_input, finding_id, info, origin)
            else:
                raise InvalidFileSize()
        else:
            raise InvalidFileType()
        ret = UploadFile(success=success)
        if success:
            update_last_vuln_date(finding_id)
            util.invalidate_cache(finding_id)
            util.invalidate_cache(project)
            util.cloudwatch_log(info.context, 'Security: Uploaded file in {project} \
                project succesfully'.format(project=project))
        else:
            util.cloudwatch_log(info.context, 'Security: Attempted to delete file \
                from {project} project'.format(project=project))
        return ret


def validate_file_schema(file_url, info):
    """Validate if a file has the correct schema."""
    schema_dir = os.path.dirname(os.path.abspath(__file__))
    schema_dir = os.path.join(schema_dir, 'schema.yaml')
    core = Core(source_file=file_url, schema_files=[schema_dir])
    is_valid = False
    try:
        core.validate(raise_exception=True)
        is_valid = True
    except SchemaError:
        lines_of_exceptions = core.errors
        errors_values = \
            [x.value for x in lines_of_exceptions if not hasattr(x, 'key')]
        errors_keys = \
            [x for x in lines_of_exceptions if hasattr(x, 'key')]
        errors_values_formated = \
            ['"{val}"'.format(val=x) for x in errors_values]
        errors_keys_formated = \
            ['"{val}"'.format(val=x.key) for x in errors_keys
                if x.msg and str(x.msg).find('was not defined') >= 0]
        errors_keys_joined = ','.join(errors_keys_formated)
        errors_values_joined = ','.join(errors_values_formated)
        error_value = '"values": [{values}], "keys": [{keys}]'.format(
            values=errors_values_joined,
            keys=errors_keys_joined
        )
        util.cloudwatch_log(
            info.context,
            'Error: An error occurred validating vulnerabilities file')
        raise InvalidSchema(expr=error_value)
    except CoreError:
        raise InvalidSchema()
    finally:
        os.unlink(file_url)
    return is_valid


def process_file(file_input, finding_id, info, origin):
    """Process a file."""
    success = False
    raw_content = file_input.read()
    raw_content = raw_content.decode()
    file_content = html.escape(raw_content, quote=False)
    file_input.seek(0)
    vulnerabilities = yaml.safe_load(file_content)
    file_url = f'/tmp/vulnerabilities-{_uuid.uuid4()}-{finding_id}.yaml'
    with open(file_url, 'w') as stream:
        yaml.safe_dump(vulnerabilities, stream)

    if validate_file_schema(file_url, info):
        success = map_vulns_to_dynamo(vulnerabilities, finding_id, info, origin)
    else:
        success = False
    return success


def map_vulns_to_dynamo(vulnerabilities, finding_id, info, origin):
    """Map vulnerabilities and send it to dynamo."""
    where = ['inputs', 'lines', 'ports']
    vulns_added = []
    for vuln in where:
        file_vuln = vulnerabilities.get(vuln)
        if file_vuln:
            inputs_added = list(
                map(lambda x, vuln=vuln: add_vulnerability(
                    x, vuln, finding_id, info, origin), file_vuln))
            vulns_added.append(all(inputs_added))
        else:
            pass
            # If a file does not have a type of vulnerabilities,
            # this does not represent an error or an exceptional condition.
    if vulns_added:
        success = all(vulns_added)
    else:
        success = False
    return success


def add_vulnerability_aux(vuln, specific, data, finding_id, info):
    """Add vulnerability auxiliar."""
    response = False
    if vuln in ('lines', 'ports'):
        specific_values = ungroup_specific(specific)
    else:
        specific_values = [spec for spec in specific.split(',') if spec]
    if (vuln == 'ports' and not
            all((0 <= int(i) <= 65535)
                for i in specific_values)):
        error_value = '"values": "{port}"'.format(
            port=specific
        )
        raise InvalidPort(expr=error_value)
    if not specific_values:
        raise InvalidSpecific()

    vuln_added = \
        [add_vuln_to_dynamo(data, i, vuln,
                            finding_id, info)
            for i in specific_values]
    response = all(vuln_added)
    return response


def add_vulnerability(item, vuln_type, finding_id, info, origin):
    """Add vulnerability to dynamo."""
    where_haders = {
        'inputs': {'where': 'url', 'specific': 'field'},
        'lines': {'where': 'path', 'specific': 'line'},
        'ports': {'where': 'host', 'specific': 'port'}
    }
    for vuln, vuln_info in list(where_haders.items()):
        if vuln_type == vuln:
            where = item.get(vuln_info.get('where'))
            specific = item.get(vuln_info.get('specific'))
            data = {
                'where': where,
                'state': item.get('state'),
                'origin': origin if origin else 'api'
            }
            if vuln == 'lines' and where.find('\\') >= 0:
                error_value = '"values": "{path}"'.format(
                    path=where.replace('\\', '\\\\')
                )
                raise InvalidPath(expr=error_value)
            if is_range(specific) or is_secuence(specific):
                response = add_vulnerability_aux(
                    vuln, specific, data, finding_id, info)
            else:
                if vuln == 'ports' and not 0 <= int(specific) <= 65535:
                    error_value = '"values": "{port}"'.format(port=specific)
                    raise InvalidPort(expr=error_value)
                response = add_vuln_to_dynamo(
                    data, specific, vuln_type, finding_id, info)
    return response


def update_last_vuln_date(finding_id):
    inc = 0
    has_new_open_vulns = False
    vulnerabilities = integrates_dal.get_vulnerabilities_dynamo(finding_id)
    today_date = str(datetime.today().strftime('%Y-%m-%d %H:%M:%S'))
    while inc < len(vulnerabilities) and has_new_open_vulns is False:
        vuln_historics = vulnerabilities[inc].get('historic_state')
        current_state = vuln_historics[len(vuln_historics) - 1].get('state')
        current_date = vuln_historics[len(vuln_historics) - 1].get('date')
        if current_state == 'open' and \
           current_date.split(' ')[0] == today_date.split(' ')[0] and \
           not vuln_historics[-1].get('approval_status'):
            primary_keys = ['finding_id', str(finding_id)]
            description = {'lastVulnerability': today_date}
            integrates_dal.add_multiple_attributes_dynamo(
                'FI_findings', primary_keys, description)
            has_new_open_vulns = True
        else:
            inc += 1
    success = has_new_open_vulns
    return success
