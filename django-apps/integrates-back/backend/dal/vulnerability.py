"""DAL functions for vulnerabilities."""

from typing import Dict, List, cast
from datetime import datetime
import pytz
import rollbar
from django.conf import settings
from boto3.dynamodb.conditions import Attr, Key
from botocore.exceptions import ClientError

from backend.dal.finding import FindingType
from backend.dal.helpers import dynamodb

DYNAMODB_RESOURCE = dynamodb.DYNAMODB_RESOURCE  # type: ignore
TABLE = DYNAMODB_RESOURCE.Table('FI_vulnerabilities')


def get_vulnerabilities(finding_id: str) -> List[Dict[str, FindingType]]:
    """Get vulnerabilities of the given finding"""
    filter_exp = Key('finding_id').eq(finding_id)
    response = TABLE.query(KeyConditionExpression=filter_exp)
    vulns = response.get('Items', [])
    while 'LastEvaluatedKey' in response:
        response = TABLE.query(
            KeyConditionExpression=filter_exp,
            ExclusiveStartKey=response['LastEvaluatedKey'])
        vulns += response.get('Items', [])

    return vulns


def update(finding_id: str, vuln_id: str, data: Dict[str, FindingType]) -> bool:
    success = False
    primary_keys = {'finding_id': finding_id, 'UUID': vuln_id}
    try:
        attrs_to_remove = [attr for attr in data if data[attr] is None]
        for attr in attrs_to_remove:
            response = TABLE.update_item(
                Key=primary_keys,
                UpdateExpression='REMOVE #attr',
                ExpressionAttributeNames={'#attr': attr}
            )
            success = response['ResponseMetadata']['HTTPStatusCode'] == 200
            del data[attr]

        if data:
            attributes = ['#{attr} = :{attr}'.format(attr=attr)
                          for attr in data]
            values = {':{}'.format(attr): data[attr] for attr in data}

            response = TABLE.update_item(
                Key=primary_keys,
                UpdateExpression='SET {}'.format(','.join(attributes)),
                ExpressionAttributeNames={
                    '#{}'.format(attr): attr for attr in data
                },
                ExpressionAttributeValues=values)
            success = response['ResponseMetadata']['HTTPStatusCode'] == 200
    except ClientError as ex:
        rollbar.report_message('Error: Couldn\'nt update vulnerability',
                               'error', extra_data=ex, payload_data=locals())

    return success


def update_state(
        finding_id: str, vuln_id: str, attr_name: str,
        attr_value: FindingType, item: List[Dict[str, str]]) -> bool:
    resp = False
    try:
        if attr_name not in item[0]:
            TABLE.update_item(
                Key={
                    'finding_id': str(finding_id),
                    'UUID': vuln_id,
                },
                UpdateExpression='SET #attrName = :val1',
                ExpressionAttributeNames={
                    '#attrName': attr_name
                },
                ExpressionAttributeValues={
                    ':val1': []
                }
            )
        update_response = TABLE.update_item(
            Key={
                'finding_id': str(finding_id),
                'UUID': vuln_id
            },
            UpdateExpression='SET #attrName = list_append(#attrName, :val1)',
            ExpressionAttributeNames={
                '#attrName': attr_name
            },
            ExpressionAttributeValues={
                ':val1': attr_value
            }
        )
        resp = update_response['ResponseMetadata']['HTTPStatusCode'] == 200
    except ClientError:
        rollbar.report_exc_info()
    return resp


def create(data: Dict[str, FindingType]) -> bool:
    """Add vulnerabilities."""
    resp = False
    try:
        item = {
            'finding_id': str(data.get('finding_id')),
            'UUID': str(data.get('UUID')),
            'vuln_type': data.get('vuln_type'),
            'where': data.get('where'),
            'specific': str(data.get('specific')),
            'historic_state': data.get('historic_state')
        }
        if 'treatment_manager' in data:
            item['treatment_manager'] = data.get('treatment_manager')
        response = TABLE.put_item(
            Item=item
        )
        resp = response['ResponseMetadata']['HTTPStatusCode'] == 200
    except ClientError:
        rollbar.report_exc_info()
    return resp


def delete(uuid: str, finding_id: str) -> bool:
    """Delete a vulnerability of a finding."""
    resp = False
    try:
        response = TABLE.delete_item(
            Key={
                'UUID': uuid,
                'finding_id': finding_id
            }
        )
        resp = response['ResponseMetadata']['HTTPStatusCode'] == 200
    except ClientError:
        rollbar.report_exc_info()
    return resp


def get(finding_id: str, vuln_type: str = '', where: str = '',
        specific: str = '', uuid: str = '') -> List[Dict[str, FindingType]]:
    """Get a vulnerability."""
    hash_key = 'finding_id'
    if finding_id and uuid:
        range_key = 'UUID'
        key_exp: object = Key(hash_key).eq(finding_id) & Key(range_key).eq(uuid)
        response = TABLE.query(KeyConditionExpression=key_exp)
    elif finding_id and vuln_type and where and specific:
        key_exp = Key(hash_key).eq(finding_id)
        filtering_exp = Attr('vuln_type').eq(vuln_type) & Attr('where').eq(where) \
            & Attr('specific').eq(str(specific))
        response = TABLE.query(
            KeyConditionExpression=key_exp,
            FilterExpression=filtering_exp)
    else:
        response = TABLE.query()
    items = response['Items']
    while response.get('LastEvaluatedKey'):
        if filtering_exp:
            response = TABLE.query(
                KeyConditionExpression=key_exp,
                FilterExpression=filtering_exp,
                ExclusiveStartKey=response['LastEvaluatedKey'])
        else:
            response = TABLE.query(
                KeyConditionExpression=key_exp,
                ExclusiveStartKey=response['LastEvaluatedKey'])
        items += response['Items']
    return items


def request_verification(vuln: Dict[str, FindingType]) -> bool:
    tzn = pytz.timezone(settings.TIME_ZONE)  # type: ignore
    today = datetime.now(tz=tzn).today().strftime('%Y-%m-%d %H:%M:%S')
    historic_verification = cast(List[Dict[str, str]], vuln.get('historic_verification', []))
    new_state: Dict[str, str] = {
        'date': today,
        'status': 'REQUESTED',
    }
    historic_verification.append(new_state)
    return update(
        str(vuln.get('finding_id', '')),
        str(vuln.get('UUID', '')),
        {'historic_verification': historic_verification}
    )


def verify_vulnerability(vuln: Dict[str, FindingType]) -> bool:
    tzn = pytz.timezone(settings.TIME_ZONE)  # type: ignore
    today = datetime.now(tz=tzn).today().strftime('%Y-%m-%d %H:%M:%S')
    historic_verification = cast(List[Dict[str, str]], vuln.get('historic_verification', []))
    new_state: Dict[str, str] = {
        'date': today,
        'status': 'VERIFIED',
    }
    historic_verification.append(new_state)
    return update(
        str(vuln.get('finding_id', '')),
        str(vuln.get('UUID', '')),
        {'historic_verification': historic_verification}
    )
