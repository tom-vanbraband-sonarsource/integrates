"""Domain functions for vulnerabilities."""

import html
import html.parser
import copy
import itertools
import os
import threading
import uuid
from datetime import datetime
from time import time
from operator import itemgetter
from typing import Collection, Dict, List, Iterable, Union, cast
import yaml
from pykwalify.core import Core
from pykwalify.errors import CoreError, SchemaError
from graphql import GraphQLError

import pytz
import rollbar
from django.conf import settings
from i18n import t

from backend.domain import (
    user as user_domain
)
from backend import util
from backend.exceptions import (
    AlreadyRequested, InvalidPath, InvalidPort, InvalidSchema, InvalidSpecific,
    NotVerificationRequested, VulnAlreadyClosed, VulnNotFound
)
from backend.mailer import send_mail_updated_vulns
from backend.utils import (
    vulnerabilities as vuln_utils, findings as finding_utils,
    notifications, validations
)

from backend.dal import (
    finding as finding_dal, project as project_dal,
    vulnerability as vuln_dal, comment as comment_dal
)
from backend.typing import Finding as FindingType, User as UserType


def sort_vulnerabilities(item: List[str]) -> List[str]:
    """Sort a vulnerability by its where field."""
    sorted_item = sorted(item, key=itemgetter('where'))
    return sorted_item


def group_specific(specific: List[str], vuln_type: str) -> List[Dict[str, FindingType]]:
    """Group vulnerabilities by its specific field."""
    sorted_specific = sort_vulnerabilities(specific)
    lines = []
    vuln_keys = ['historic_state', 'vuln_type', 'UUID', 'finding_id']
    for key, group in itertools.groupby(sorted_specific,
                                        key=lambda x: x['where']):  # type: ignore
        vuln_info = list(group)
        if vuln_type == 'inputs':
            specific_grouped: List[Union[int, str]] = [
                cast(Dict[str, str], i).get('specific', '') for i in vuln_info]
            dictlines: Dict[str, FindingType] = \
                {'where': key, 'specific': ','.join(cast(List[str], specific_grouped))}
        else:
            specific_grouped = [get_specific(cast(Dict[str, str], i)) for i in vuln_info]
            specific_grouped.sort()
            dictlines = {'where': key, 'specific': get_ranges(cast(List[int], specific_grouped))}
        if vuln_info and all(key_vuln in vuln_info[0] for key_vuln in vuln_keys):
            dictlines.update({key_vuln: cast(Dict[str, FindingType], vuln_info[0]).get(key_vuln)
                             for key_vuln in vuln_keys})
        else:
            # Vulnerability doesn't have more attributes.
            pass
        lines.append(dictlines)
    return lines


def get_specific(value: Dict[str, str]) -> int:
    """Get specific value."""
    return int(value.get('specific', ''))


def as_range(iterable: Iterable) -> str:
    """Convert range into string."""
    my_list = list(iterable)
    range_value = ''
    if len(my_list) > 1:
        range_value = '{0}-{1}'.format(my_list[0], my_list[-1])
    else:
        range_value = '{0}'.format(my_list[0])
    return range_value


def get_ranges(numberlist: List[int]) -> str:
    """Transform list into ranges."""
    range_str = ','.join(as_range(g) for _, g in itertools.groupby(
        numberlist,
        key=lambda n,  # type: ignore
        c=itertools.count(): n - next(c))
    )
    return range_str


def approve_vulnerability(finding_id: str,
                          historic_state: List[Dict[str, str]], last_state: Dict[str, str],
                          vulnerability: List[Dict[str, str]]) -> bool:
    """ Approve vulnerability """
    tzn = pytz.timezone(settings.TIME_ZONE)  # type: ignore
    current_day = datetime.now(tz=tzn).today().strftime('%Y-%m-%d %H:%M:%S')
    current_state = {
        'date': current_day,
        'state': last_state.get('state', ''),
        'approval_status': 'APPROVED',
        'analyst': last_state.get('analyst', '')}

    historic_state[-1] = current_state
    return vuln_dal.update_state(
        finding_id,
        str(vulnerability[0].get('UUID', '')),
        'historic_state',
        historic_state,
        vulnerability)


def reject_vulnerability(finding_id: str, historic_state: List[Dict[str, str]],
                         vulnerability: List[Dict[str, str]], vuln_id: str) -> bool:
    """ Reject vulnerability: remove last_state of historic_state or remove
        if only one state present in historic_state """
    historic_state.pop()
    response = False
    if historic_state:
        response = vuln_dal.update_state(
            finding_id,
            str(vulnerability[0].get('UUID', '')),
            'historic_state',
            historic_state,
            vulnerability)
    else:
        response = vuln_dal.delete(vuln_id, finding_id)
    return response


def update_approval_status(finding_id: str, vuln_id: str, approval_status: str) -> bool:
    """ Update vulnerability approval state """
    vulnerability = cast(List[Dict[str, str]], vuln_dal.get(finding_id, uuid=vuln_id))
    response = False

    if vulnerability:
        historic_state = cast(List[Dict[str, str]], vulnerability[0].get('historic_state'))
        last_state = historic_state[-1]
        del vulnerability[0]['historic_state']

        if last_state.get('approval_status') == 'PENDING':
            if approval_status:
                response = \
                    approve_vulnerability(finding_id, historic_state,
                                          last_state, vulnerability)
            else:
                response = reject_vulnerability(
                    finding_id, historic_state, vulnerability, vuln_id)
        else:
            # vuln approval_status is different than pending
            pass
    else:
        # vuln not found
        pass

    return response


def update_vuln_state(info, vulnerability: List[Dict[str, str]],
                      item: Dict[str, str], finding_id: str, current_day: str) -> bool:
    """Update vulnerability state."""
    historic_state = cast(List[Dict[str, str]], vulnerability[0].get('historic_state'))
    last_state = historic_state[len(historic_state) - 1]
    response = False
    if last_state.get('state') != item.get('state'):
        historic_state = []
        user_data = cast(UserType, util.get_jwt_content(info.context))
        analyst = str(user_data['user_email'])
        if util.is_api_token(user_data):
            current_state = {
                'date': current_day,
                'state': item.get('state', ''),
                'origin': item.get('origin', ''),
                'approval_status': 'PENDING',
                'analyst': 'api-{email}'.format(email=analyst)}
        else:
            current_state = {
                'date': current_day,
                'state': item.get('state', ''),
                'analyst': analyst}

        historic_state.append(current_state)
        remove_treatment_manager = True
        if item.get('state') == 'closed':
            remove_treatment_manager = vuln_dal.update(
                finding_id,
                vulnerability[0].get('UUID', ''),
                {'treatment_manager': None})
        response = vuln_dal.update_state(
            finding_id,
            str(vulnerability[0].get('UUID', '')),
            'historic_state',
            historic_state,
            vulnerability) and remove_treatment_manager
    else:
        response = True
    return response


def add_vuln_to_dynamo(
        item: Dict[str, str], specific: str, vuln: str, finding_id: str, info) -> bool:
    """Add vulnerability to dynamo."""
    historic_state = []
    last_finding_state = cast(List[Dict[str, str]],
                              finding_dal.get_finding(finding_id)['historic_treatment'])[-1]
    where = item.get('where', '')
    vulnerability = cast(List[Dict[str, str]],
                         vuln_dal.get(finding_id, vuln_type=vuln, where=where, specific=specific))
    response = False
    tzn = pytz.timezone(settings.TIME_ZONE)  # type: ignore
    current_day = datetime.now(tz=tzn).today().strftime('%Y-%m-%d %H:%M:%S')
    user_data = cast(UserType, util.get_jwt_content(info.context))
    email = str(user_data['user_email'])
    if vulnerability:
        response = update_vuln_state(info, vulnerability, item, finding_id, current_day)
    else:
        data: Dict[str, FindingType] = {}
        data['vuln_type'] = vuln
        data['where'] = where
        data['specific'] = specific
        data['finding_id'] = finding_id
        data['UUID'] = str(uuid.uuid4())
        data['treatment'] = 'NEW'
        if last_finding_state['treatment'] != 'NEW':
            data['treatment_manager'] = last_finding_state.get('user', '')
        if item.get('state'):
            if util.is_api_token(user_data):
                historic_state.append({
                    'date': current_day,
                    'state': item.get('state', ''),
                    'origin': item.get('origin', ''),
                    'approval_status': 'PENDING',
                    'analyst': 'api-{email}'.format(email=email)})
            else:
                historic_state.append({
                    'date': current_day,
                    'state': item.get('state', ''),
                    'analyst': email})

            data['historic_state'] = historic_state
            response = vuln_dal.create(data)
        else:
            util.cloudwatch_log(
                info.context,
                'Security: Attempted to add vulnerability without state')
    return response


def update_vulnerabilities_date(analyst: str, finding_id: str):
    """Update vulnerabilities date when a verification is required."""
    vulnerabilities = cast(List[Dict[str, str]], finding_dal.get_vulnerabilities(finding_id))
    for vuln in vulnerabilities:
        all_states = cast(List[Dict[str, str]], vuln.get('historic_state', []))
        current_state: Dict[str, str] = all_states[len(all_states) - 1]
        tzn = pytz.timezone(settings.TIME_ZONE)  # type: ignore
        last_date = datetime.strptime(
            str(current_state.get('date')).split(' ')[0],
            '%Y-%m-%d'
        )
        last_date = cast(datetime, last_date.replace(tzinfo=tzn).date())
        current_date = datetime.now(tz=tzn).date()
        if last_date != current_date:
            historic_state: List[Dict[str, str]] = []
            current_time = datetime.now(tz=tzn).today().strftime('%Y-%m-%d %H:%M:%S')
            last_state = {
                'date': current_time,
                'state': current_state.get('state', ''),
                'analyst': analyst}
            historic_state.append(last_state)
            vuln_dal.update_state(
                finding_id,
                vuln.get('UUID', ''),
                'historic_state',
                historic_state,
                [vuln])
        else:
            # A finding that change the same day should not be updated
            pass


def process_file(file_input, finding_id: str, info, origin: str) -> bool:
    """Process a file."""
    success = False
    raw_content = file_input.read()
    raw_content = raw_content.decode()
    file_content = html.escape(raw_content, quote=False)
    file_input.seek(0)
    vulnerabilities = yaml.safe_load(file_content)
    file_url = f'/tmp/vulnerabilities-{uuid.uuid4()}-{finding_id}.yaml'
    with open(file_url, 'w') as stream:
        yaml.safe_dump(vulnerabilities, stream)
    if validate_file_schema(file_url, info):
        success = map_vulns_to_dynamo(vulnerabilities, finding_id, info, origin)
    else:
        success = False
    return success


def map_vulns_to_dynamo(vulnerabilities: Dict[str, FindingType],
                        finding_id: str, info, origin: str) -> bool:
    """Map vulnerabilities and send it to dynamo."""
    where = ['inputs', 'lines', 'ports']
    vulns_added = []
    for vuln in where:
        file_vuln = vulnerabilities.get(vuln)
        if file_vuln:
            inputs_added = list(
                map(lambda x,  # type: ignore
                    vuln=vuln: add_vulnerability(x, vuln, finding_id, info, origin),
                    cast(List[str], file_vuln)))
            vulns_added.append(all(inputs_added))
        else:
            pass
            # If a file does not have a type of vulnerabilities,
            # this does not represent an error or an exceptional condition.
    if vulns_added:
        success = all(vulns_added)
    else:
        success = False
    return success


def validate_file_schema(file_url: str, info) -> bool:
    """Validate if a file has the correct schema."""
    schema_dir = os.path.dirname(os.path.abspath(__file__))
    schema_dir = os.path.join(schema_dir, '../entity/schema.yaml')
    core = Core(source_file=file_url, schema_files=[schema_dir])
    is_valid = False
    try:
        core.validate(raise_exception=True)
        is_valid = True
    except SchemaError:
        lines_of_exceptions = core.errors
        errors_values = \
            [x.value for x in lines_of_exceptions if not hasattr(x, 'key')]
        errors_keys = \
            [x for x in lines_of_exceptions if hasattr(x, 'key')]
        errors_values_formated = \
            ['"{val}"'.format(val=x) for x in errors_values]
        errors_keys_formated = \
            ['"{val}"'.format(val=x.key) for x in errors_keys
                if x.msg and str(x.msg).find('was not defined') >= 0]
        errors_keys_joined = ','.join(errors_keys_formated)
        errors_values_joined = ','.join(errors_values_formated)
        error_value = '"values": [{values}], "keys": [{keys}]'.format(
            values=errors_values_joined,
            keys=errors_keys_joined
        )
        util.cloudwatch_log(
            info.context,
            'Error: An error occurred validating vulnerabilities file')
        raise InvalidSchema(expr=error_value)
    except CoreError:
        raise InvalidSchema()
    finally:
        os.unlink(file_url)
    return is_valid


def update_last_vuln_date(finding_id: str) -> bool:
    inc = 0
    has_new_open_vulns = False
    vulnerabilities = finding_dal.get_vulnerabilities(finding_id)
    today_date = str(datetime.today().strftime('%Y-%m-%d %H:%M:%S'))
    while inc < len(vulnerabilities) and has_new_open_vulns is False:
        vuln_historics = cast(List[Dict[str, str]], vulnerabilities[inc].get('historic_state'))
        current_state = vuln_historics[len(vuln_historics) - 1].get('state', '')
        current_date = vuln_historics[len(vuln_historics) - 1].get('date', '')
        if current_state == 'open' and current_date.split(' ')[0] == today_date.split(' ')[0] and \
           ('approval_status' not in vuln_historics[-1] or
           vuln_historics[-1].get('approval_status') == 'APPROVED'):
            description: Dict[str, FindingType] = {'lastVulnerability': today_date}
            finding_dal.update(finding_id, description)
            has_new_open_vulns = True
        else:
            inc += 1
    success = has_new_open_vulns
    return success


def send_updated_vuln_email(finding_id: str, user_email: str, data_vuln: Dict[str, str],
                            updated_vuln_description: str):
    """Send email when vulnerabilities were updated"""
    if len(updated_vuln_description) == 1:
        number_vuln = 'vulnerability'
    else:
        number_vuln = 'vulnerabilities'
    project_name = \
        str(finding_dal.get_attributes(finding_id, ['project_name']).get('project_name')).lower()
    recipients = project_dal.get_users(project_name, True)

    finding_name = finding_dal.get_attributes(finding_id, ['finding']).get('finding')

    email_send_thread = threading.Thread(
        name='Updated vulnerabilities email thread',
        target=send_mail_updated_vulns,
        args=(recipients, {
            'user_email': user_email,
            'finding_name': finding_name,
            'number_vuln': number_vuln,
            'project': project_name.capitalize(),
            'treatment': str(data_vuln['treatment']).lower(),
            'updated_vuln_description': updated_vuln_description,
            'justification': data_vuln.get('treatment_justification', ''),
            'treatment_manager': data_vuln.get('treatment_manager', ''),
        }))

    email_send_thread.start()


def update_treatment_vuln(vulnerabilities: List[str], finding_id: str,
                          updated_values: Dict[str, FindingType], info) -> bool:
    if updated_values.get('acceptance_date'):
        del updated_values['acceptance_date']
    del updated_values['finding_id']
    user_email = util.get_jwt_content(info.context)['user_email']
    updated_vuln_description = []
    for vulnerability in vulnerabilities:
        vuln_info = cast(
            List[Dict[str, FindingType]], vuln_dal.get(finding_id, uuid=vulnerability))
        new_info = copy.copy(updated_values)
        if new_info.get('tag'):
            new_info['tag'] = cast(List[str], vuln_info[0].get('tag', []))
            for tag in str(updated_values['tag']).split(','):
                validations.validate_field(cast(List[str], tag))
                if tag.strip():
                    cast(List[str], new_info['tag']).append(tag.strip())
            new_info['tag'] = cast(
                # conflict between mypy and pylint -> 'github.com/PyCQA/pylint/issues/2377'
                # pylint: disable=unsubscriptable-object
                List[str], list(set(cast(Iterable[Collection[str]], new_info['tag']))))
            new_info['tag'] = [html.unescape(tag) for tag in cast(List[str], new_info['tag'])]
        new_info = {key: None if not value else value for key, value in new_info.items()}
        new_info = {util.camelcase_to_snakecase(k): new_info.get(k) for k in new_info}
        result_update_vuln = \
            vuln_dal.update(finding_id,
                            vulnerability,
                            new_info)
        if 'lines' in str(vuln_info[0]['vuln_type']):
            where = 'Path'
            specific = 'Line'
        elif 'ports' in str(vuln_info[0]['vuln_type']):
            where = 'Host'
            specific = 'Port'
        else:
            where = 'URL'
            specific = 'Field'
        mail_description =\
            "<b>{where}:</b>{where_info}&nbsp;&nbsp;&nbsp;\
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>{specific}:</b> {specific_info}"\
            .format(where=where, where_info=vuln_info[0]['where'],
                    specific_info=vuln_info[0]['specific'], specific=specific)
        updated_vuln_description.append({'updated_vuln_description': mail_description})
        if not result_update_vuln:
            util.cloudwatch_log(info.context, 'Security: Attempted to update vulnerability\
            :{id} from finding:{finding}'.format(id=vulnerability, finding=finding_id))
            return False
        util.cloudwatch_log(info.context, 'Security: Updated vulnerability:\
        {id} from finding:{finding} succesfully'.format(id=vulnerability, finding=finding_id))
    if updated_values.get('treatment') != 'NEW':
        send_updated_vuln_email(finding_id, user_email, cast(Dict[str, str], updated_values),
                                str(updated_vuln_description))

    return True


def update_treatments(vulnerabilities: List[str], finding_id: str,
                      updated_values: Dict[str, FindingType],
                      info, is_customer_admin: bool) -> bool:
    """Update treatments data in vulnerability"""
    user_data = util.get_jwt_content(info.context)
    finding = finding_dal.get_finding(finding_id)
    updated_values['treatment'] = cast(List[Dict[str, str]],
                                       finding.get('historic_treatment'))[-1]['treatment']
    updated_values['treatment_manager'] = \
        set_treatment_manager(
            str(updated_values.get('treatment', '')),
            str(updated_values.get('treatment_manager', '')),
            finding, is_customer_admin, user_data['user_email'])
    updated_values.pop('external_bts', None)
    updated_values.pop('vulnerabilities', None)
    if updated_values.get('tag') == '':
        updated_values.pop('tag', None)
    return update_treatment_vuln(
        vulnerabilities, finding_id, updated_values, info)


def set_treatment_manager(treatment: str, treatment_manager: str,
                          finding: Dict[str, FindingType], is_customer_admin: bool,
                          user_mail: str) -> str:
    if treatment == 'IN PROGRESS':
        if not is_customer_admin:
            treatment_manager = user_mail
        if treatment_manager:
            project_users = project_dal.get_users(str(finding.get('project_name')))
            customer_roles = ['customer', 'customeradmin']
            customer_users = \
                [user for user in project_users
                    if user_domain.get_data(user, 'role') in customer_roles]
            if treatment_manager not in customer_users:
                raise GraphQLError('Invalid treatment manager')
        else:
            raise GraphQLError('Invalid treatment manager')
    elif treatment == 'ACCEPTED':
        treatment_manager = user_mail
    elif treatment == 'ACCEPTED_UNDEFINED':
        last_state = cast(List[Dict[str, str]], finding.get('historic_treatment'))[-1]
        if last_state['acceptance_status'] == 'SUBMITTED':
            treatment_manager = user_mail
        else:
            treatment_manager = last_state['user']
    return treatment_manager


def get_open_vuln_by_type(finding_id: str, context) -> Dict[str, Union[int, List[str]]]:
    """Get open vulnerabilities group by type."""
    vulnerabilities = finding_dal.get_vulnerabilities(finding_id)
    finding: Dict[str, Union[int, List[str]]] = {
        'openVulnerabilities': 0,
        'closedVulnerabilities': 0,
        'portsVulns': [],
        'linesVulns': [],
        'inputsVulns': []
    }
    vulns_types = ['ports', 'lines', 'inputs']
    for vuln in vulnerabilities:
        current_state = get_last_approved_status(vuln)
        if current_state == 'open':
            finding['openVulnerabilities'] += 1  # type: ignore
            if vuln.get('vuln_type') in vulns_types:
                finding[vuln.get('vuln_type', '') + 'Vulns'].append({  # type: ignore
                    'where': vuln.get('where'),
                    'specific': vuln.get('specific')
                })
            else:
                error_msg = 'Error: Vulnerability {vuln_id} of finding \
                    {finding_id} does not have the right type'\
                    .format(vuln_id=vuln.get('UUID'), finding_id=finding_id)
                rollbar.report_message(error_msg, 'error')
        elif current_state == 'closed':
            finding['closedVulnerabilities'] += 1  # type: ignore
        else:
            error_msg = 'Error: Vulnerability {vuln_id} of finding \
                {finding_id} does not have the right state'\
                .format(vuln_id=vuln.get('UUID'), finding_id=finding_id)
            util.cloudwatch_log(context, error_msg)
    return finding


def get_vulnerabilities_by_type(finding_id: str) -> Dict[str, List[FindingType]]:
    """Get vulnerabilities group by type."""
    vulnerabilities = finding_dal.get_vulnerabilities(finding_id)
    vulnerabilities = [vuln for vuln in vulnerabilities
                       if cast(List[Dict[str, str]], vuln['historic_state'])[-1].get('state')
                       != 'DELETED']
    vulnerabilities_grouped = cast(List[Dict[str, FindingType]],
                                   group_vulnerabilities(vulnerabilities))
    vulnerabilities_formatted = format_vulnerabilities(vulnerabilities_grouped)
    return vulnerabilities_formatted


def group_vulnerabilities(vulnerabilities: List[Dict[str, FindingType]]) -> List[FindingType]:
    """Group vulnerabilities by specific field."""
    vuln_types = ['lines', 'ports', 'inputs']
    vuln_states = ['open', 'closed']
    total_vulnerabilities: Dict[str, Dict[str, FindingType]] = {}
    result_vulns: List[FindingType] = []
    for vuln_type in vuln_types:
        total_vulnerabilities[vuln_type] = {}
        for vuln_state in vuln_states:
            total_vulnerabilities[vuln_type][vuln_state] = []

    for vuln in vulnerabilities:
        all_states = cast(List[Dict[str, FindingType]], vuln.get('historic_state', [{}]))
        current_state = str(all_states[len(all_states) - 1].get('state', ''))
        current_approval_status = all_states[len(all_states) - 1].get(
            'approval_status', '')
        vuln_type = str(vuln.get('vuln_type', ''))
        if current_approval_status != 'PENDING' or \
           get_last_approved_status(vuln):
            cast(List[Dict[str, FindingType]],
                 total_vulnerabilities[vuln_type][current_state]).append(vuln)
        else:
            # vuln has pending approval_status
            pass

    for vuln_type in vuln_types:
        for vuln_state in vuln_states:
            vulns_grouped = cast(Iterable[FindingType], group_specific(
                cast(List[str], total_vulnerabilities[vuln_type][vuln_state]), vuln_type))
            result_vulns.extend(vulns_grouped)
    return result_vulns


def format_vulnerabilities(
        vulnerabilities: List[Dict[str, FindingType]]) -> \
        Dict[str, List[FindingType]]:
    """Format vulnerabilitites."""
    finding: Dict[str, List[FindingType]] = {
        'ports': [],
        'lines': [],
        'inputs': []
    }
    vulns_types = ['ports', 'lines', 'inputs']
    vuln_values = {
        'ports': {
            'where': 'host',
            'specific': 'port',
        },
        'lines': {
            'where': 'path',
            'specific': 'line'
        },
        'inputs': {
            'where': 'url',
            'specific': 'field'
        }
    }
    for vuln in vulnerabilities:
        all_states = cast(List[Dict[str, FindingType]], vuln.get('historic_state'))
        current_state = all_states[len(all_states) - 1].get('state')
        vuln_type = str(vuln.get('vuln_type', ''))
        if vuln_type in vulns_types:
            finding[vuln_type].append({
                vuln_values[vuln_type]['where']:
                    html.parser.HTMLParser().unescape(vuln.get('where')),  # type: ignore
                vuln_values[vuln_type]['specific']:
                    html.parser.HTMLParser().unescape(vuln.get('specific')),  # type: ignore
                'state': str(current_state)
            })
        else:
            error_msg = 'Error: Vulnerability {vuln_id} of finding \
                {finding_id} does not have the right type'\
                .format(vuln_id=vuln.get('UUID'), finding_id=vuln.get('finding_id'))
            rollbar.report_message(error_msg, 'error')
    return finding


def get_vulnerabilities(finding_id: str) -> List[Dict[str, FindingType]]:
    vulnerabilities = [vuln_utils.format_data(vuln)
                       for vuln in vuln_dal.get_vulnerabilities(finding_id)]

    return vulnerabilities


def list_vulnerabilities(
        finding_ids: List[str]) -> List[Dict[str, FindingType]]:
    """Retrieves all vulnerabilities for the requested findings"""
    vulns: List[Dict[str, FindingType]] = []
    for finding_id in finding_ids:
        vulns += get_vulnerabilities(finding_id)

    return vulns


def get_last_approved_status(vuln: Dict[str, FindingType]) -> str:
    historic_state = cast(List[Dict[str, str]], vuln['historic_state'])
    last_approved = ''
    for state in list(reversed(historic_state)):
        if state.get('approval_status') == 'APPROVED' or \
           not state.get('approval_status'):
            last_approved = state.get('state', '')
            break

    return last_approved


def filter_deleted_status(vuln: Dict[str, FindingType]) -> bool:
    historic_state = cast(List[Dict[str, str]], vuln['historic_state'])
    last_approved = True
    for state in historic_state:
        if state.get('state') == 'DELETED':
            last_approved = False
            break

    return last_approved


def get_current_state(vuln: Dict[str, FindingType]) -> str:
    last_approved = get_last_approved_status(vuln)
    if last_approved:
        state = last_approved
    else:
        state = cast(List[Dict[str, str]], vuln['historic_state'])[-1].get('state', '')
    return state


def get_last_approved_analyst(vuln: Dict[str, FindingType]) -> str:
    historic_state = cast(List[Dict[str, str]], vuln['historic_state'])
    last_analyst = ''
    for state in list(reversed(historic_state)):
        if state.get('approval_status') == 'APPROVED' or \
           not state.get('approval_status'):
            last_analyst = state.get('analyst', '')
            break

    return last_analyst


def get_last_approved_state(vuln: Dict[str, FindingType]) -> Dict[str, str]:
    historic_state = cast(List[Dict[str, str]], vuln['historic_state'])
    last_approved_state: Dict[str, str] = {}
    for state in list(reversed(historic_state)):
        if state.get('approval_status') == 'APPROVED' or \
           not state.get('approval_status'):
            last_approved_state = state
            break

    return last_approved_state


def update_all_pending_vulns(finding_id: str, approval_status: str) -> bool:
    list_vulns = get_vulnerabilities(finding_id)
    list_pending_vulns = \
        [vuln for vuln in list_vulns
         if cast(List[Dict[str, str]], vuln['historic_state'])[-1]
         .get('approval_status', '') == 'PENDING']
    return all([update_approval_status(
                finding_id, str(vuln.get('UUID', '')), approval_status)
                for vuln in list_pending_vulns])


def mask_vuln(finding_id: str, vuln_id: str) -> bool:
    success = vuln_dal.update(finding_id, vuln_id, {
        'specific': 'Masked',
        'where': 'Masked'
    })

    return success


def delete_vulnerability(
        finding_id: str, vuln_id: str, justification: str, user_email: str) -> bool:
    vulnerability = vuln_dal.get(finding_id, uuid=vuln_id)
    success = False

    if vulnerability and vulnerability[0].get('historic_state'):
        all_states = cast(List[Dict[str, str]], vulnerability[0].get('historic_state'))
        current_state = all_states[-1].get('state')
        if current_state == 'open':
            tzn = pytz.timezone(settings.TIME_ZONE)  # type: ignore
            current_day = datetime.now(tz=tzn).today().strftime(
                '%Y-%m-%d %H:%M:%S')
            new_state = {
                'date': current_day,
                'state': 'DELETED',
                'justification': justification,
                'analyst': user_email}
            success = vuln_dal.update_state(
                finding_id, str(vulnerability[0].get('UUID', '')), 'historic_state',
                [new_state], cast(List[Dict[str, str]], vulnerability))

    return success


def delete_tags(finding_id: str, vulnerabilities: List[str]) -> bool:
    success = []
    for vulnerability in vulnerabilities:
        result = vuln_dal.update(finding_id, vulnerability, {'tag': []})
        success.append(result)

    return all(success)


def add_vulnerability_aux(
        vuln: str, specific: str, data: Dict[str, str], finding_id: str, info) -> bool:
    """Add vulnerability auxiliar."""
    response = False
    if vuln in ('lines', 'ports'):
        specific_values = vuln_utils.ungroup_specific(specific)
    else:
        specific_values = [spec for spec in specific.split(',') if spec]
    if (vuln == 'ports' and not
            all((0 <= int(i) <= 65535)
                for i in specific_values)):
        error_value = '"values": "{port}"'.format(
            port=specific
        )
        raise InvalidPort(expr=error_value)
    if not specific_values:
        raise InvalidSpecific()

    vuln_added = \
        [add_vuln_to_dynamo(data, i, vuln,
                            finding_id, info)
            for i in specific_values]
    response = all(vuln_added)
    return response


def add_vulnerability(item: Dict[str, FindingType], vuln_type: str,
                      finding_id: str, info, origin: str) -> bool:
    """Add vulnerability to dynamo."""
    where_haders = {
        'inputs': {'where': 'url', 'specific': 'field'},
        'lines': {'where': 'path', 'specific': 'line'},
        'ports': {'where': 'host', 'specific': 'port'}
    }
    for vuln, vuln_info in list(where_haders.items()):
        if vuln_type == vuln:
            where = str(item.get(vuln_info.get('where', '')))
            specific = str(item.get(vuln_info.get('specific', '')))
            data: Dict[str, str] = {
                'where': where,
                'state': str(item.get('state', '')),
                'origin': origin if origin else 'api'
            }
            if vuln == 'lines' and where.find('\\') >= 0:
                error_value = '"values": "{path}"'.format(
                    path=where.replace('\\', '\\\\')
                )
                raise InvalidPath(expr=error_value)
            if vuln_utils.is_range(specific) or vuln_utils.is_sequence(specific):
                response = add_vulnerability_aux(
                    vuln, specific, data, finding_id, info)
            else:
                if vuln == 'ports' and not 0 <= int(specific) <= 65535:
                    error_value = '"values": "{port}"'.format(port=specific)
                    raise InvalidPort(expr=error_value)
                response = add_vuln_to_dynamo(
                    data, specific, vuln_type, finding_id, info)
    return response


def get(finding_id: str, vuln_id: str):
    vuln = cast(List[Dict[str, FindingType]], vuln_dal.get(finding_id, uuid=vuln_id))
    first_vuln = cast(Dict[str, List[Dict[str, str]]], vuln[0])
    if not vuln:
        raise VulnNotFound()
    if first_vuln.get('historic_state', [{}])[-1].get('state', '') == 'DELETED':
        raise VulnNotFound()
    return vuln[0]


def get_by_ids(finding_id: str, vulns_ids: List[str]) -> List[Dict[str, FindingType]]:
    vulnerabilities = [get(finding_id, vuln_id) for vuln_id in vulns_ids]

    return vulnerabilities


def validate_requested_verification(vuln: Dict[str, FindingType]) -> Dict[str, FindingType]:
    """ Validate vuln is not resquested """
    historic_verification = cast(List[Dict[str, FindingType]],
                                 vuln.get('historic_verification', [{}]))
    if historic_verification[-1].get('status', '') == 'REQUESTED':
        raise AlreadyRequested()
    return vuln


def validate_closed(vuln: Dict[str, FindingType]) -> Dict[str, FindingType]:
    """ Validate vuln closed """
    if cast(List[Dict[str, FindingType]],
            vuln.get('historic_state', [{}]))[-1].get('state') == 'closed':
        raise VulnAlreadyClosed()
    return vuln


def request_verification(finding_id: str, user_email: str, user_fullname: str,
                         justification: str, vuln_ids: List[str]) -> bool:
    finding = finding_dal.get_finding(finding_id)
    vulnerabilities = get_by_ids(finding_id, vuln_ids)
    vulnerabilities = [validate_requested_verification(vuln) for vuln in vulnerabilities]
    vulnerabilities = [validate_closed(vuln) for vuln in vulnerabilities]
    if not vulnerabilities:
        raise VulnNotFound()
    comment_id = int(round(time() * 1000))
    tzn = pytz.timezone(settings.TIME_ZONE)  # type: ignore
    today = datetime.now(tz=tzn).today().strftime('%Y-%m-%d %H:%M:%S')
    historic_verification = cast(List[Dict[str, Union[str, int, List[str]]]],
                                 finding.get('historic_verification', []))
    historic_verification.append({
        'date': today,
        'user': user_email,
        'status': 'REQUESTED',
        'comment': comment_id,
        'vulns': vuln_ids
    })
    update_finding = finding_dal.update(
        finding_id, {'historic_verification': historic_verification})
    comment_data = {
        'comment_type': 'verification',
        'content': justification,
        'created': today,
        'email': user_email,
        'finding_id': int(finding_id),
        'fullname': user_fullname,
        'modified': today,
        'parent': 0,
    }
    comment_dal.create(comment_id, comment_data)
    update_vulns = [vuln_dal.request_verification(vuln) for vuln in vulnerabilities]
    if all(update_vulns) and update_finding:
        finding_utils.send_remediation_email(
            user_email, finding_id, str(finding.get('finding', '')),
            str(finding.get('project_name', '')), justification)
        project_users = project_dal.get_users(str(finding.get('project_name', '')))
        notifications.notify_mobile(
            project_users,
            t('notifications.remediated.title'),
            t('notifications.remediated.content',
                finding=finding.get('finding'),
                project=str(finding.get('project_name', '')).upper()))
    else:
        rollbar.report_message(
            'Error: An error occurred remediating', 'error')

    return all(update_vulns)


def validate_verify(vuln: Dict[str, FindingType]) -> Dict[str, FindingType]:
    """ Validate vuln is resquested """
    historic_verification = vuln.get('historic_verification', [{}])
    if cast(List[Dict[str, str]], historic_verification)[-1].get('status', '') != 'REQUESTED':
        raise NotVerificationRequested()
    return vuln


def verify_vulnerabilities(finding_id: str, user_email: str, user_fullname: str,
                           info, parameters: Dict[str, FindingType]) -> bool:
    finding = finding_dal.get_finding(finding_id)
    vuln_ids = \
        cast(List[str], parameters.get('open_vulns', [])) + \
        cast(List[str], parameters.get('closed_vulns', []))
    vulnerabilities = get_by_ids(finding_id, vuln_ids)
    vulnerabilities = [validate_verify(vuln) for vuln in vulnerabilities]
    vulnerabilities = [validate_closed(vuln) for vuln in vulnerabilities]
    if not vulnerabilities:
        raise VulnNotFound()
    tzn = pytz.timezone(settings.TIME_ZONE)  # type: ignore
    today = datetime.now(tz=tzn).today().strftime('%Y-%m-%d %H:%M:%S')
    comment_id = int(round(time() * 1000))
    historic_verification = cast(List[Dict[str, Union[str, int, List[str]]]],
                                 finding.get('historic_verification', []))
    historic_verification.append({
        'date': today,
        'user': user_email,
        'status': 'VERIFIED',
        'comment': comment_id,
        'vulns': vuln_ids
    })
    update_finding = finding_dal.update(
        finding_id, {'historic_verification': historic_verification})
    comment_data: comment_dal.CommentType = {
        'comment_type': 'verification',
        'content': parameters.get('justification', ''),
        'created': today,
        'email': user_email,
        'finding_id': int(finding_id),
        'fullname': user_fullname,
        'modified': today,
        'parent': 0,
    }
    comment_dal.create(comment_id, comment_data)
    success = [vuln_dal.verify_vulnerability(vuln) for vuln in vulnerabilities]
    if all(success) and update_finding:
        success = verify(
            info, finding_id, cast(List[Dict[str, str]], vulnerabilities),
            cast(List[str], parameters.get('closed_vulns', [])), today)
    else:
        rollbar.report_message(
            'Error: An error occurred verifying', 'error')
    return all(success)


def verify(info, finding_id: str, vulnerabilities: List[Dict[str, str]],
           closed_vulns: List[str], date) -> List[bool]:
    finding = finding_dal.get_finding(finding_id)
    success = [update_vuln_state(info, [vuln], {'state': 'closed'}, finding_id, date)
               for vuln in vulnerabilities
               if vuln.get('UUID') in closed_vulns]
    finding_utils.send_finding_verified_email(
        finding_id, str(finding.get('finding', '')), str(finding.get('project_name', '')))
    project_users = project_dal.get_users(str(finding.get('project_name', '')))
    notifications.notify_mobile(
        project_users,
        t('notifications.verified.title'),
        t('notifications.verified.content',
            finding=str(finding.get('finding', '')),
            project=str(finding.get('project_name', '')).upper()))

    return success
