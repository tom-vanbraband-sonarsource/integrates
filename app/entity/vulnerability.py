""" GraphQL Entity for Vulnerability  """
# pylint: disable=no-self-use
import html
import os
from datetime import datetime

import yaml
from django.core.files.uploadedfile import (
    InMemoryUploadedFile, TemporaryUploadedFile
)
from graphene import String, ObjectType, Boolean, Mutation, List
from graphene.types.generic import GenericScalar
from magic import Magic
from pykwalify.core import Core
from pykwalify.errors import CoreError, SchemaError

from app.decorators import require_login, require_role, require_finding_access
from app.domain.vulnerability import (
    is_range, is_secuence, ungroup_specific, add_vuln_to_dynamo,
    update_all_pending_vulns, update_approval_status, update_treatments
)
from app.domain.project import (
    get_finding_project_name
)
from app import util
from app.exceptions import (
    InvalidRange, InvalidSchema, InvalidFileSize, InvalidFileType, InvalidPort,
    InvalidPath, InvalidSpecific
)
from app.dal import integrates_dal


class Vulnerability(ObjectType):
    """Vulnerability Class."""

    id = String()  # noqa pylint: disable=invalid-name
    analyst = String()
    finding_id = String()
    vuln_type = String()
    where = String()
    specific = String()
    historic_state = List(GenericScalar)
    current_state = String()
    current_approval_status = String()
    last_analyst = String()
    last_approved_status = String()
    treatment = String()
    external_bts = String()
    treatment_justification = String()
    treatment_manager = String()

    def __getitem__(self, key):
        if key == 'UUID':
            key = 'id'
        return getattr(self, key)

    def resolve_treatment_manager(self, info):
        """Resolve Treatment Manager"""
        del info
        return self.treatment_manager

    def resolve_treatment_justification(self, info):
        """Resolve Treatment Justification"""
        del info
        return self.treatment_justification

    def resolve_external_bts(self, info):
        """Resolve External Bts"""
        del info
        return self.external_bts

    def resolve_id(self, info):
        """Resolve id attribute."""
        del info
        return self.id

    def resolve_treatment(self, info):
        """Resolve treatment attribute."""
        del info
        return self.treatment

    def resolve_finding_id(self, info):
        """Resolve vulnerabilities attribute."""
        del info
        return self.finding_id

    def resolve_vuln_type(self, info):
        """Resolve vulnerabilities attribute."""
        del info
        return self.vuln_type

    def resolve_where(self, info):
        """Resolve vulnerabilities attribute."""
        del info
        return self.where

    def resolve_specific(self, info):
        """Resolve vulnerabilities attribute."""
        del info
        return self.specific

    def resolve_historic_state(self, info):
        """Resolve vulnerabilities attribute."""
        del info
        return self.historic_state

    def resolve_current_state(self, info):
        """Resolve vulnerabilities attribute."""
        del info
        return self.current_state

    def resolve_current_approval_status(self, info):
        """Resolve vulnerabilities attribute."""
        del info
        return self.current_approval_status

    def resolve_last_approved_status(self, info):
        """Resolve vulnerabilities attribute."""
        del info
        return self.last_approved_status

    @require_role(['analyst', 'admin'])
    def resolve_last_analyst(self, info):
        """ Resolve last approved analyst attribute """
        del info
        return self.last_analyst

    @require_role(['analyst', 'admin'])
    def resolve_analyst(self, info):
        """ Resolve analyst attribute """
        del info
        return self.analyst


class ApproveVulnerability(Mutation):
    """Approve a vulnerability."""

    class Arguments(object):
        """Arguments of the class."""
        uuid = String()
        finding_id = String(required=True)
        approval_status = Boolean(required=True)

    success = Boolean()

    @require_login
    @require_role(['analyst', 'admin'])
    @require_finding_access
    def mutate(self, info, finding_id, approval_status, uuid=''):
        project_name = get_finding_project_name(finding_id)
        success = False
        if uuid:
            success = update_approval_status(
                finding_id, uuid, approval_status)
        else:
            success = update_all_pending_vulns(finding_id, approval_status)
        if success:
            util.invalidate_cache(finding_id)
            util.invalidate_cache(project_name)
            util.cloudwatch_log(
                info.context, 'Security: Approve vulnerability from {project}\
                    project succesfully'.format(
                    project=project_name))
        else:
            util.cloudwatch_log(info.context, 'Security: Attempted to approve\
                vulnerability from {project} project'.format(
                project=project_name))

        ret = ApproveVulnerability(success=success)
        return ret


class UpdateTreatmentVuln(Mutation):
    """Update treatment info in vulnerabilites"""

    class Arguments(object):
        """Arguments of the class."""

        data = GenericScalar(required=True)  # noqa pylint: disable=invalid-name
        finding_id = String()
    success = Boolean()

    @require_login
    @require_role(['customer', 'admin'])
    @require_finding_access
    def mutate(self, info, **parameters):
        """update vulnerabilities in database."""

        data = parameters.get('data')
        vulnerabilities = data.get('vulnerabilities')
        finding_id = data.get('findingId')
        treatments_field = ['treatment', 'treatmentJustification', 'treatmentManager',
                            'btsUrl']
        data_snakecase = {util.camelcase_to_snakecase(k): str(data.get(k))
                          for k in treatments_field}
        if 'bts_url' in list(data_snakecase.keys()):
            data_snakecase['external_bts'] = data_snakecase.get('bts_url')
            del data_snakecase['bts_url']
        data_snakecase['last_update'] = str(datetime.today().strftime('%Y-%m-%d %H:%M:%S'))
        result_update_vuln = update_treatments(vulnerabilities, finding_id,
                                               data_snakecase, info)
        if result_update_vuln:
            util.invalidate_cache(finding_id)
        result = UpdateTreatmentVuln(success=result_update_vuln)
        return result


class DeleteVulnerability(Mutation):
    """Delete a vulnerability."""

    class Arguments(object):
        """Arguments of the class."""

        id = String(required=True)  # noqa pylint: disable=invalid-name
        finding_id = String(required=True)
    success = Boolean()

    @require_login
    @require_role(['analyst', 'admin'])
    @require_finding_access
    def mutate(self, info, **kwargs):
        """Delete vulnerability from database."""
        finding_id = kwargs.get('finding_id')
        uuid = kwargs.get('id')
        project = integrates_dal.get_finding_project(finding_id)
        release_date_dynamo = integrates_dal.get_finding_attributes_dynamo(
            finding_id,
            ['releaseDate'])
        release_date = release_date_dynamo.get('releaseDate', '')
        success = False

        vulnerability = integrates_dal.get_vulnerability_dynamo(finding_id, uuid=uuid)
        if vulnerability and vulnerability[0].get('historic_state'):
            all_states = vulnerability[0].get('historic_state')
            current_state = all_states[len(all_states) - 1].get('state')
            if current_state == 'open' and not release_date:
                was_deleted = integrates_dal.delete_vulnerability_dynamo(uuid, finding_id)
                success = was_deleted
            else:
                success = False
        else:
            success = False
        if success:
            util.invalidate_cache(finding_id)
            util.invalidate_cache(project)
            util.cloudwatch_log(info.context, 'Security: Deleted vulnerability: {id} \
                from {project} project succesfully'.format(id=uuid, project=project))
        else:
            util.cloudwatch_log(info.context, 'Security: Attempted to delete vulnerability \
                :{id} from {project} project'.format(id=uuid, project=project))
        ret = DeleteVulnerability(success=success)
        return ret


class UploadFile(Mutation):
    """Upload a file with the vulnerabilities."""

    class Arguments(object):
        """Arguments of the class."""

        finding_id = String(required=True)
    success = Boolean()

    @require_login
    @require_role(['analyst', 'admin'])
    @require_finding_access
    def mutate(self, info, **kwargs):
        """Process file input."""
        finding_id = kwargs.get('finding_id')
        project = integrates_dal.get_finding_project(finding_id)
        file_input = info.context.FILES.get('document', None)
        mime = Magic(mime=True)
        if isinstance(file_input, TemporaryUploadedFile):
            mime_type = mime.from_file(file_input.temporary_file_path())
        elif isinstance(file_input, InMemoryUploadedFile):
            mime_type = mime.from_buffer(file_input.file.getvalue())
        else:
            mime_type = ''
        mib = 1048576
        if (file_input and
                mime_type in ['text/x-yaml', 'text/plain', 'text/html']):
            if file_input.size < 1 * mib:
                try:
                    success = process_file(file_input, finding_id, info)
                except (InvalidRange, InvalidSchema, InvalidPort):
                    raise
            else:
                raise InvalidFileSize()
        else:
            raise InvalidFileType()
        ret = UploadFile(success=success)
        if success:
            update_last_vuln_date(finding_id)
            util.invalidate_cache(finding_id)
            util.invalidate_cache(project)
            util.cloudwatch_log(info.context, 'Security: Uploaded file in {project} \
                project succesfully'.format(project=project))
        else:
            util.cloudwatch_log(info.context, 'Security: Attempted to delete file \
                from {project} project'.format(project=project))
        return ret


def process_file(file_input, finding_id, info):
    """Process a file."""
    success = False
    raw_content = file_input.read()
    raw_content = raw_content.decode()
    # We do not want '&' in our yaml to prevent recursive DoS
    #   escape '<' and '>' too
    file_content = html.escape(raw_content, quote=False)
    file_input.seek(0)
    vulnerabilities = yaml.safe_load(file_content)
    file_url = '/tmp/vulnerabilities.yaml'
    stream = open(file_url, 'w')
    yaml.safe_dump(vulnerabilities, stream)
    try:
        is_valid_schema = validate_file_schema(file_url, info)
    except InvalidSchema:
        raise
    if is_valid_schema:
        try:
            success = map_vulns_to_dynamo(vulnerabilities, finding_id, info)
        except (InvalidRange, InvalidPort):
            raise
    else:
        success = False
    return success


def validate_file_schema(file_url, info):
    """Validate if a file has the correct schema."""
    schema_dir = os.path.dirname(os.path.abspath(__file__))
    schema_dir = os.path.join(schema_dir, 'schema.yaml')
    core = Core(source_file=file_url, schema_files=[schema_dir])
    is_valid = False
    try:
        core.validate(raise_exception=True)
        is_valid = True
    except SchemaError:
        lines_of_exceptions = core.errors
        errors_values = \
            [x.value for x in lines_of_exceptions if not hasattr(x, 'key')]
        errors_keys = \
            [x for x in lines_of_exceptions if hasattr(x, 'key')]
        errors_values_formated = \
            ['"{val}"'.format(val=x) for x in errors_values]
        errors_keys_formated = \
            ['"{val}"'.format(val=x.key) for x in errors_keys
                if x.msg and str(x.msg).find('was not defined') >= 0]
        errors_keys_joined = ','.join(errors_keys_formated)
        errors_values_joined = ','.join(errors_values_formated)
        error_value = '"values": [{values}], "keys": [{keys}]'.format(
            values=errors_values_joined,
            keys=errors_keys_joined
        )
        util.cloudwatch_log(
            info.context,
            'Error: An error occurred validating vulnerabilities file')
        raise InvalidSchema(expr=error_value)
    except CoreError:
        raise InvalidSchema()
    return is_valid


def map_vulns_to_dynamo(vulnerabilities, finding_id, info):
    """Map vulnerabilities and send it to dynamo."""
    where = ['inputs', 'lines', 'ports']
    vulns_added = []
    for vuln in where:
        file_vuln = vulnerabilities.get(vuln)
        if file_vuln:
            try:
                inputs_added = list(
                    map(lambda x, vuln=vuln: add_vulnerability(x, vuln, finding_id, info),
                        file_vuln))
            except InvalidRange:
                raise
            vulns_added.append(all(inputs_added))
        else:
            pass
            # If a file does not have a type of vulnerabilities,
            # this does not represent an error or an exceptional condition.
    if vulns_added:
        success = all(vulns_added)
    else:
        success = False
    return success


def add_vulnerability(item, vuln_type, finding_id, info):
    """Add vulnerability to dynamo."""
    where_haders = {
        'inputs': {'where': 'url', 'specific': 'field'},
        'lines': {'where': 'path', 'specific': 'line'},
        'ports': {'where': 'host', 'specific': 'port'}
    }
    for vuln, vuln_info in list(where_haders.items()):
        if vuln_type == vuln:
            where = item.get(vuln_info.get('where'))
            specific = item.get(vuln_info.get('specific'))
            data = {
                'where': where,
                'state': item.get('state')
            }
            if vuln == 'lines' and where.find('\\') >= 0:
                error_value = '"values": "{path}"'.format(
                    path=where.replace('\\', '\\\\')
                )
                raise InvalidPath(expr=error_value)
            if is_range(specific) or is_secuence(specific):
                response = add_vulnerability_aux(
                    vuln, specific, data, finding_id, info)
            else:
                if vuln == 'ports' and not 0 <= int(specific) <= 65535:
                    error_value = '"values": "{port}"'.format(port=specific)
                    raise InvalidPort(expr=error_value)
                else:
                    response = add_vuln_to_dynamo(
                        data, specific, vuln_type, finding_id, info)
    return response


def add_vulnerability_aux(vuln, specific, data, finding_id, info):
    """Add vulnerability auxiliar."""
    response = False
    try:
        if vuln == 'lines' or vuln == 'ports':
            specific_values = ungroup_specific(specific)
        else:
            specific_values = [spec for spec in specific.split(',') if spec]
        if (vuln == 'ports' and not
                all((0 <= int(i) <= 65535)
                    for i in specific_values)):
            error_value = '"values": "{port}"'.format(
                port=specific
            )
            raise InvalidPort(expr=error_value)
        elif not specific_values:
            raise InvalidSpecific()
        else:
            # Vulnerability has a valid value
            pass
    except InvalidRange:
        raise
    else:
        vuln_added = \
            [add_vuln_to_dynamo(data, i, vuln,
                                finding_id, info)
                for i in specific_values]
        response = all(vuln_added)
    return response


def update_last_vuln_date(finding_id):
    inc = 0
    has_new_open_vulns = False
    vulnerabilities = integrates_dal.get_vulnerabilities_dynamo(finding_id)
    today_date = str(datetime.today().strftime('%Y-%m-%d %H:%M:%S'))
    while inc < len(vulnerabilities) and has_new_open_vulns is False:
        vuln_historics = vulnerabilities[inc].get('historic_state')
        current_state = vuln_historics[len(vuln_historics) - 1].get('state')
        current_date = vuln_historics[len(vuln_historics) - 1].get('date')
        if current_state == 'open' and \
           current_date.split(' ')[0] == today_date.split(' ')[0] and \
           not vuln_historics[-1].get('approval_status'):
            primary_keys = ['finding_id', str(finding_id)]
            description = {'lastVulnerability': today_date}
            integrates_dal.add_multiple_attributes_dynamo(
                'FI_findings', primary_keys, description)
            has_new_open_vulns = True
        else:
            inc += 1
    success = has_new_open_vulns
    return success
