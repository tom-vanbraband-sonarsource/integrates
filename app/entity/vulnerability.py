""" GraphQL Entity for Vulnerability  """
# pylint: disable=F0401
# pylint: disable=no-self-use
# pylint: disable=super-init-not-called
# pylint: disable=relative-beyond-top-level
# Disabling this rule is necessary for importing modules beyond the top level
# directory.
from datetime import datetime
import cgi

import yaml
from magic import Magic
from graphene import String, ObjectType, Boolean, Mutation, List
from graphene.types.generic import GenericScalar
from pykwalify.core import Core
from pykwalify.errors import CoreError, SchemaError
from django.core.files.uploadedfile import (
    InMemoryUploadedFile, TemporaryUploadedFile
)

from app.decorators import require_login, require_role, require_finding_access
from app.domain.vulnerability import (
    is_range, is_secuence, ungroup_specific, add_vuln_to_dynamo,
    update_treatments
)
from .. import util
from ..exceptions import (
    InvalidRange, InvalidSchema, InvalidFileSize, InvalidFileType, InvalidPort,
    InvalidSpecific
)
from ..dao import integrates_dao

FILE_PATH = '/usr/src/app/app/entity/'


class Vulnerability(ObjectType):  # noqa pylint: disable=too-many-instance-attributes
    """Vulnerability Class."""

    id = String()  # noqa pylint: disable=invalid-name
    finding_id = String()
    vuln_type = String()
    where = String()
    specific = String()
    historic_state = List(GenericScalar)
    current_state = String()
    treatment = String()

    def __init__(self, vuln_data):
        """Class constructor."""
        self.access = False
        self.id = ''  # noqa pylint: disable=invalid-name

        finding_id = str(vuln_data.get('finding_id'))
        if vuln_data.get('vuln_type') == 'old':
            self.where = vuln_data.get('where')
        else:
            self.id = vuln_data.get('UUID')
            self.vuln_type = vuln_data.get('vuln_type')
            self.where = vuln_data.get('where')
            self.specific = vuln_data.get('specific')
            self.finding_id = finding_id
            all_states = vuln_data.get('historic_state')
            self.historic_state = all_states
            self.current_state = all_states[len(all_states) - 1].get('state')
            treatment = vuln_data.get('treatment', '')
            self.treatment = treatment.lower().capitalize()

    def resolve_id(self, info):
        """Resolve id attribute."""
        del info
        return self.id

    def resolve_treatment(self, info):
        """Resolve treatment attribute."""
        del info
        return self.treatment

    def resolve_finding_id(self, info):
        """Resolve vulnerabilities attribute."""
        del info
        return self.finding_id

    def resolve_vuln_type(self, info):
        """Resolve vulnerabilities attribute."""
        del info
        return self.vuln_type

    def resolve_where(self, info):
        """Resolve vulnerabilities attribute."""
        del info
        return self.where

    def resolve_specific(self, info):
        """Resolve vulnerabilities attribute."""
        del info
        return self.specific

    def resolve_historic_state(self, info):
        """Resolve vulnerabilities attribute."""
        del info
        return self.historic_state

    def resolve_current_state(self, info):
        """Resolve vulnerabilities attribute."""
        del info
        return self.current_state


class UpdateTreatmentVuln(Mutation):
    """Update treatment info in vulnerabilites"""

    class Arguments(object):
        """Arguments of the class."""

        data = GenericScalar(required=True)  # noqa pylint: disable=invalid-name
        finding_id = String()
    success = Boolean()

    @require_login
    @require_role(['customer'])
    @require_finding_access
    def mutate(self, info, **parameters):
        """update vulnerabilities in database."""

        data = parameters.get('data')
        if 'bts_url' in data.keys():
            data['external_bts'] = data.get('bts_url')
            del data['bts_url']
        finding_id = data.get('findingId')
        vulnerabilities = data.get('vulnerabilities')
        del data['findingId']
        del data['vulnerabilities']
        result_update_vuln = update_treatments(vulnerabilities, finding_id,
                                               data, info)
        result = UpdateTreatmentVuln(success=result_update_vuln)
        util.invalidate_cache(finding_id)
        return result


class DeleteVulnerability(Mutation):
    """Delete a vulnerability."""

    class Arguments(object):
        """Arguments of the class."""

        id = String(required=True)  # noqa pylint: disable=invalid-name
        finding_id = String(required=True)
    success = Boolean()

    @require_login
    @require_role(['analyst', 'admin'])
    @require_finding_access
    def mutate(self, info, **kwargs):
        """Delete vulnerability from database."""
        finding_id = kwargs.get('finding_id')
        uuid = kwargs.get('id')
        project = integrates_dao.get_finding_project(finding_id)
        release_date_dynamo = integrates_dao.get_finding_attributes_dynamo(
            finding_id,
            ['releaseDate'])
        release_date = release_date_dynamo.get('releaseDate', '')
        success = False

        vulnerability = integrates_dao.get_vulnerability_dynamo(finding_id, uuid=uuid)
        if vulnerability and vulnerability[0].get('historic_state'):
            all_states = vulnerability[0].get('historic_state')
            current_state = all_states[len(all_states) - 1].get('state')
            if current_state == 'open' and not release_date:
                was_deleted = integrates_dao.delete_vulnerability_dynamo(uuid, finding_id)
                success = was_deleted
            else:
                success = False
        else:
            success = False
        if success:
            util.cloudwatch_log(info.context, 'Security: Deleted vulnerability: {id} \
                from {project} project succesfully'.format(id=uuid, project=project))
        else:
            util.cloudwatch_log(info.context, 'Security: Attempted to delete vulnerability \
                :{id} from {project} project'.format(id=uuid, project=project))
        ret = DeleteVulnerability(success=success)
        util.invalidate_cache(finding_id)
        util.invalidate_cache(project)
        return ret


class UploadFile(Mutation):
    """Upload a file with the vulnerabilities."""

    class Arguments(object):
        """Arguments of the class."""

        finding_id = String(required=True)
    success = Boolean()

    @require_login
    @require_role(['analyst', 'admin'])
    @require_finding_access
    def mutate(self, info, **kwargs):
        """Process file input."""
        finding_id = kwargs.get('finding_id')
        project = integrates_dao.get_finding_project(finding_id)
        file_input = info.context.FILES.get('document', None)
        mime = Magic(mime=True)
        if isinstance(file_input, TemporaryUploadedFile):
            mime_type = mime.from_file(file_input.temporary_file_path())
        elif isinstance(file_input, InMemoryUploadedFile):
            mime_type = mime.from_buffer(file_input.file.getvalue())
        else:
            mime_type = ''
        mib = 1048576
        if (file_input and
                mime_type in ['text/x-yaml', 'text/plain', 'text/html']):
            if file_input.size < 1 * mib:
                try:
                    success = process_file(file_input, finding_id, info)
                except (InvalidRange, InvalidSchema, InvalidPort):
                    raise
            else:
                raise InvalidFileSize()
        else:
            raise InvalidFileType()
        ret = UploadFile(success=success)
        if success:
            update_last_vuln_date(finding_id)
            util.cloudwatch_log(info.context, 'Security: Uploaded file in {project} \
                project succesfully'.format(project=project))
        else:
            util.cloudwatch_log(info.context, 'Security: Attempted to delete file \
                from {project} project'.format(project=project))
        util.invalidate_cache(finding_id)
        util.invalidate_cache(project)
        return ret


def process_file(file_input, finding_id, info):
    """Process a file."""
    success = False
    file_content = cgi.escape(file_input.read())
    file_input.seek(0)
    vulnerabilities = yaml.safe_load(file_content)
    file_url = '/tmp/vulnerabilities.yaml'
    stream = file(file_url, 'w')
    yaml.safe_dump(vulnerabilities, stream)
    try:
        is_valid_schema = validate_file_schema(file_url, info)
    except InvalidSchema:
        raise
    if is_valid_schema:
        try:
            success = map_vulns_to_dynamo(vulnerabilities, finding_id, info)
        except (InvalidRange, InvalidPort):
            raise
    else:
        success = False
    return success


def validate_file_schema(file_url, info):
    """Validate if a file has the correct schema."""
    core = Core(source_file=file_url, schema_files=[FILE_PATH + 'schema.yaml'])
    is_valid = False
    try:
        core.validate(raise_exception=True)
        is_valid = True
    except (CoreError, SchemaError):
        util.cloudwatch_log(
            info.context,
            'Error: An error occurred validating vulnerabilities file')
        raise InvalidSchema()
    return is_valid


def map_vulns_to_dynamo(vulnerabilities, finding_id, info):
    """Map vulnerabilities and send it to dynamo."""
    where = ['inputs', 'lines', 'ports']
    vulns_added = []
    for vuln in where:
        file_vuln = vulnerabilities.get(vuln)
        if file_vuln:
            try:
                inputs_added = list(
                    map(lambda x, vuln=vuln: add_vulnerability(x, vuln, finding_id, info),
                        file_vuln))
            except InvalidRange:
                raise
            vulns_added.append(all(inputs_added))
        else:
            pass
            # If a file does not have a type of vulnerabilities,
            # this does not represent an error or an exceptional condition.
    if vulns_added:
        success = all(vulns_added)
    else:
        success = False
    return success


def add_vulnerability(item, vuln_type, finding_id, info):
    """Add vulnerability to dynamo."""
    where_haders = {
        'inputs': {'where': 'url', 'specific': 'field'},
        'lines': {'where': 'path', 'specific': 'line'},
        'ports': {'where': 'host', 'specific': 'port'}
    }
    response = False
    for vuln, vuln_info in where_haders.items():
        if vuln_type == vuln:
            where = item.get(vuln_info.get('where'))
            specific = item.get(vuln_info.get('specific'))
            data = {
                'where': where,
                'state': item.get('state')
            }
            if is_range(specific) or is_secuence(specific):
                try:
                    if vuln == 'lines' or vuln == 'ports':
                        specific_values = ungroup_specific(specific)
                    else:
                        specific_values = [spec for spec in specific.split(',') if spec]
                    if (vuln == 'ports' and not
                            all((0 <= int(i) <= 65535)
                                for i in specific_values)):
                        raise InvalidPort()
                    elif not specific_values:
                        raise InvalidSpecific()
                    else:
                        # Vulnerability has a valid value
                        pass
                except InvalidRange:
                    raise
                else:
                    vuln_added = \
                        [add_vuln_to_dynamo(data, i, vuln,
                                            finding_id, info)
                         for i in specific_values]
                    response = all(vuln_added)
            else:
                if vuln == 'ports' and not 0 <= int(specific) <= 65535:
                    raise InvalidPort()
                else:
                    response = add_vuln_to_dynamo(
                        data, specific, vuln_type, finding_id, info)
    return response


def update_last_vuln_date(finding_id):
    inc = 0
    has_new_open_vulns = False
    vulnerabilities = integrates_dao.get_vulnerabilities_dynamo(finding_id)
    today_date = str(datetime.today().strftime('%Y-%m-%d %H:%M:%S'))
    while inc < len(vulnerabilities) and has_new_open_vulns is False:
        vuln_historics = vulnerabilities[inc].get('historic_state')
        current_state = vuln_historics[len(vuln_historics) - 1].get('state')
        current_date = vuln_historics[len(vuln_historics) - 1].get('date')
        if current_state == 'open' and \
           current_date.split(' ')[0] == today_date.split(' ')[0]:
            primary_keys = ['finding_id', str(finding_id)]
            description = {'lastVulnerability': today_date}
            integrates_dao.add_multiple_attributes_dynamo('FI_findings', primary_keys, description)
            has_new_open_vulns = True
        else:
            inc += 1
    success = has_new_open_vulns
    return success
