"""Domain functions for vulnerabilities."""

import html.parser
import itertools
import threading
import uuid
from datetime import datetime
from operator import itemgetter

import pytz
import rollbar
from django.conf import settings

from app import util
from app.dal import (
    integrates_dal, project as project_dal, vulnerability as vuln_dal
)
from app.exceptions import InvalidRange
from app.mailer import send_mail_updated_vulns
from app.utils import vulnerabilities as vuln_utils


def ungroup_specific(specific):
    """Ungroup specific value."""
    values = specific.split(',')
    specific_values = []
    for val in values:
        if is_range(val):
            range_list = range_to_list(val)
            specific_values.extend(range_list)
        else:
            specific_values.append(val)
    return specific_values


def is_range(specific):
    """Validate if a specific field has range value."""
    return '-' in specific


def is_secuence(specific):
    """Validate if a specific field has secuence value."""
    return ',' in specific


def range_to_list(range_value):
    """Convert a range value into list."""
    limits = range_value.split('-')
    if int(limits[1]) > int(limits[0]):
        init_val = int(limits[0])
        end_val = int(limits[1]) + 1
    else:
        error_value = '"values": "{init_val} >= {end_val}"'.format(
            init_val=limits[0],
            end_val=limits[1]
        )
        raise InvalidRange(expr=error_value)
    specific_values = list(map(str, list(range(init_val, end_val))))
    return specific_values


def sort_vulnerabilities(item):
    """Sort a vulnerability by its where field."""
    sorted_item = sorted(item, key=itemgetter('where'))
    return sorted_item


def group_specific(specific, vuln_type):
    """Group vulnerabilities by its specific field."""
    sorted_specific = sort_vulnerabilities(specific)
    lines = []
    vuln_keys = ['historic_state', 'vuln_type', 'UUID', 'finding_id']
    for key, group in itertools.groupby(sorted_specific, key=lambda x: x['where']):
        vuln_info = list(group)
        if vuln_type == 'inputs':
            specific_grouped = [i.get('specific') for i in vuln_info]
            dictlines = {'where': key, 'specific': ','.join(specific_grouped)}
        else:
            specific_grouped = [get_specific(i) for i in vuln_info]
            specific_grouped.sort()
            dictlines = {'where': key, 'specific': get_ranges(specific_grouped)}
        if vuln_info and all(key_vuln in vuln_info[0] for key_vuln in vuln_keys):
            dictlines.update(
                {key_vuln: vuln_info[0].get(key_vuln) for key_vuln in vuln_keys})
        else:
            # Vulnerability doesn't have more attributes.
            pass
        lines.append(dictlines)
    return lines


def get_specific(value):
    """Get specific value."""
    return int(value.get('specific'))


def as_range(iterable):
    """Convert range into string."""
    my_list = list(iterable)
    range_value = ''
    if len(my_list) > 1:
        range_value = '{0}-{1}'.format(my_list[0], my_list[-1])
    else:
        range_value = '{0}'.format(my_list[0])
    return range_value


def get_ranges(numberlist):
    """Transform list into ranges."""
    range_str = ','.join(as_range(g) for _, g in itertools.groupby(
        numberlist,
        key=lambda n,
        c=itertools.count(): n - next(c))
    )
    return range_str


def approve_vulnerability(finding_id,
                          historic_state, last_state, vulnerability):
    """ Approve vulnerability """
    tzn = pytz.timezone(settings.TIME_ZONE)
    current_day = datetime.now(tz=tzn).today().strftime('%Y-%m-%d %H:%M:%S')
    current_state = {
        'date': current_day,
        'state': last_state.get('state'),
        'approval_status': 'APPROVED',
        'analyst': last_state.get('analyst')}

    historic_state[-1] = current_state
    return integrates_dal.update_state_dynamo(
        finding_id,
        vulnerability[0].get('UUID'),
        'historic_state',
        historic_state,
        vulnerability)


def reject_vulnerability(finding_id, historic_state, vulnerability, vuln_id):
    """ Reject vulnerability: remove last_state of historic_state or remove
        if only one state present in historic_state """
    historic_state.pop()
    response = False
    if historic_state:
        response = integrates_dal.update_state_dynamo(
            finding_id,
            vulnerability[0].get('UUID'),
            'historic_state',
            historic_state,
            vulnerability)
    else:
        response = integrates_dal.delete_vulnerability_dynamo(
            vuln_id, finding_id)
    return response


def update_approval_status(finding_id, vuln_id, approval_status):
    """ Update vulnerability approval state """
    vulnerability = integrates_dal.get_vulnerability_dynamo(
        finding_id, uuid=vuln_id)
    response = False

    if vulnerability:
        historic_state = vulnerability[0].get('historic_state')
        last_state = historic_state[-1]
        del vulnerability[0]['historic_state']

        if last_state.get('approval_status') == 'PENDING':
            if approval_status:
                response = \
                    approve_vulnerability(finding_id, historic_state,
                                          last_state, vulnerability)
            else:
                response = reject_vulnerability(
                    finding_id, historic_state, vulnerability, vuln_id)
        else:
            # vuln approval_status is different than pending
            pass
    else:
        # vuln not found
        pass

    return response


def update_vuln_state(info, vulnerability, item, finding_id, current_day):
    """Update vulnerability state."""
    historic_state = vulnerability[0].get('historic_state')
    last_state = historic_state[len(historic_state) - 1]
    response = False
    if last_state.get('state') != item.get('state'):
        historic_state = []
        user_data = util.get_jwt_content(info.context)
        analyst = user_data['user_email']
        if util.is_api_token(user_data):
            current_state = {
                'date': current_day,
                'state': item.get('state'),
                'origin': item.get('origin'),
                'approval_status': 'PENDING',
                'analyst': 'api-{email}'.format(email=analyst)}
        else:
            current_state = {
                'date': current_day,
                'state': item.get('state'),
                'analyst': analyst}

        historic_state.append(current_state)
        response = integrates_dal.update_state_dynamo(
            finding_id,
            vulnerability[0].get('UUID'),
            'historic_state',
            historic_state,
            vulnerability)
    else:
        response = True
    return response


def add_vuln_to_dynamo(item, specific, vuln, finding_id, info):
    """Add vulnerability to dynamo."""
    historic_state = []
    where = item.get('where')
    vulnerability = integrates_dal.get_vulnerability_dynamo(
        finding_id, vuln_type=vuln, where=where, specific=specific)
    response = False
    tzn = pytz.timezone(settings.TIME_ZONE)
    current_day = datetime.now(tz=tzn).today().strftime('%Y-%m-%d %H:%M:%S')
    user_data = util.get_jwt_content(info.context)
    email = user_data['user_email']
    if vulnerability:
        response = update_vuln_state(info, vulnerability, item, finding_id, current_day)
    else:
        data = {}
        data['vuln_type'] = vuln
        data['where'] = where
        data['specific'] = specific
        data['finding_id'] = finding_id
        data['UUID'] = str(uuid.uuid4())
        data['treatment'] = 'NEW'
        if item.get('state'):
            if util.is_api_token(user_data):
                historic_state.append({
                    'date': current_day,
                    'state': item.get('state'),
                    'origin': item.get('origin'),
                    'approval_status': 'PENDING',
                    'analyst': 'api-{email}'.format(email=email)})
            else:
                historic_state.append({
                    'date': current_day,
                    'state': item.get('state'),
                    'analyst': email})

            data['historic_state'] = historic_state
            response = integrates_dal.add_vulnerability_dynamo(
                'FI_vulnerabilities', data)
        else:
            util.cloudwatch_log(
                info.context,
                'Security: Attempted to add vulnerability without state')
    return response


def update_vulnerabilities_date(analyst, finding_id):
    """Update vulnerabilities date when a verification is required."""
    vulnerabilities = integrates_dal.get_vulnerabilities_dynamo(finding_id)
    for vuln in vulnerabilities:
        all_states = vuln.get('historic_state')
        current_state = all_states[len(all_states) - 1]
        tzn = pytz.timezone(settings.TIME_ZONE)
        last_date = datetime.strptime(
            current_state.get('date').split(" ")[0],
            '%Y-%m-%d'
        )
        last_date = last_date.replace(tzinfo=tzn).date()
        current_date = datetime.now(tz=tzn).date()
        if last_date != current_date:
            historic_state = []
            current_time = datetime.now(tz=tzn).today().strftime('%Y-%m-%d %H:%M:%S')
            last_state = {
                'date': current_time,
                'state': current_state.get('state'),
                'analyst': analyst}
            historic_state.append(last_state)
            integrates_dal.update_state_dynamo(
                finding_id,
                vuln.get('UUID'),
                'historic_state',
                historic_state,
                [vuln])
        else:
            # A finding that change the same day should not be updated
            pass


def send_updated_vuln_email(finding_id, user_email, data_vuln,
                            updated_vuln_description):
    """Send email when vulnerabilities were updated"""
    if len(updated_vuln_description) == 1:
        number_vuln = 'vulnerability'
    else:
        number_vuln = 'vulnerabilities'
    project_name = integrates_dal.get_finding_project(finding_id).lower()
    recipients = project_dal.get_users(project_name, True)

    finding_name = \
        integrates_dal.get_finding_attributes_dynamo(finding_id,
                                                     ['finding']).get('finding')

    email_send_thread = threading.Thread(
        name='Updated vulnerabilities email thread',
        target=send_mail_updated_vulns,
        args=(recipients, {
            'user_email': user_email,
            'finding_name': finding_name,
            'number_vuln': number_vuln,
            'project': project_name.capitalize(),
            'treatment': str(data_vuln['treatment']).lower(),
            'updated_vuln_description': updated_vuln_description,
            'justification': data_vuln.get('treatment_justification', ''),
        }))

    email_send_thread.start()


def update_treatments(vulnerabilities, finding_id, updated_values, info):
    """Update treatments data in vulnerability"""

    if updated_values['treatment'] in ['NEW', 'ACCEPTED']:
        updated_values['external_bts'] = ''
        if updated_values['treatment'] == 'NEW':
            updated_values['treatment_justification'] = ''
            updated_values['treatment_manager'] = ''
    user_email = util.get_jwt_content(info.context)['user_email']
    updated_vuln_description = []
    for vulnerability in vulnerabilities:
        result_update_vuln = \
            integrates_dal.update_mult_attrs_dynamo('FI_vulnerabilities',
                                                    {'finding_id': finding_id,
                                                     'UUID': vulnerability},
                                                    updated_values)
        vuln_info = integrates_dal.get_vulnerability_dynamo(finding_id, uuid=vulnerability)

        if 'lines' in vuln_info[0]['vuln_type']:
            where = 'Path'
            specific = 'Line'
        elif 'ports' in vuln_info[0]['vuln_type']:
            where = 'Host'
            specific = 'Port'
        else:
            where = 'URL'
            specific = 'Field'
        mail_description =\
            "<b>{where}:</b>{where_info}&nbsp;&nbsp;&nbsp;\
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>{specific}:</b> {specific_info}"\
            .format(where=where, where_info=vuln_info[0]['where'],
                    specific_info=vuln_info[0]['specific'], specific=specific)
        updated_vuln_description.append({'updated_vuln_description': mail_description})
        if not result_update_vuln:
            util.cloudwatch_log(info.context, 'Security: Attempted to update vulnerability\
            :{id} from finding:{finding}'.format(id=vulnerability, finding=finding_id))
            return False
        util.cloudwatch_log(info.context, 'Security: Updated vulnerability:\
        {id} from finding:{finding} succesfully'.format(id=vulnerability, finding=finding_id))
    send_updated_vuln_email(finding_id, user_email, updated_values,
                            updated_vuln_description)

    return True


def get_open_vuln_by_type(finding_id, context):
    """Get open vulnerabilities group by type."""
    vulnerabilities = integrates_dal.get_vulnerabilities_dynamo(finding_id)
    finding = {
        'openVulnerabilities': 0,
        'closedVulnerabilities': 0,
        'portsVulns': [],
        'linesVulns': [],
        'inputsVulns': []
    }
    vulns_types = ['ports', 'lines', 'inputs']
    for vuln in vulnerabilities:
        current_state = get_last_approved_status(vuln)
        if current_state == 'open':
            finding['openVulnerabilities'] += 1
            if vuln.get('vuln_type') in vulns_types:
                finding[vuln.get('vuln_type') + 'Vulns'].append({
                    'where': vuln.get('where'),
                    'specific': vuln.get('specific')
                })
            else:
                error_msg = 'Error: Vulnerability {vuln_id} of finding \
                    {finding_id} does not have the right type'\
                    .format(vuln_id=vuln.get('UUID'), finding_id=finding_id)
                rollbar.report_message(error_msg, 'error')
        elif current_state == 'closed':
            finding['closedVulnerabilities'] += 1
        else:
            error_msg = 'Error: Vulnerability {vuln_id} of finding \
                {finding_id} does not have the right state'\
                .format(vuln_id=vuln.get('UUID'), finding_id=finding_id)
            util.cloudwatch_log(context, error_msg)
    return finding


def get_vulnerabilities_by_type(finding_id):
    """Get vulnerabilities group by type."""
    vulnerabilities = integrates_dal.get_vulnerabilities_dynamo(finding_id)
    vulnerabilities = [vuln for vuln in vulnerabilities
                       if vuln['historic_state'][-1].get('state') != 'DELETED']
    vulnerabilities_grouped = group_vulnerabilities(vulnerabilities)
    vulnerabilities_formatted = format_vulnerabilities(vulnerabilities_grouped)
    return vulnerabilities_formatted


def group_vulnerabilities(vulnerabilities):
    """Group vulnerabilities by specific field."""
    vuln_types = ['lines', 'ports', 'inputs']
    vuln_states = ['open', 'closed']
    total_vulnerabilities = {}
    result_vulns = []
    for vuln_type in vuln_types:
        total_vulnerabilities[vuln_type] = {}
        for vuln_state in vuln_states:
            total_vulnerabilities[vuln_type][vuln_state] = []

    for vuln in vulnerabilities:
        all_states = vuln.get('historic_state')
        current_state = all_states[len(all_states) - 1].get('state')
        current_approval_status = all_states[len(all_states) - 1].get(
            'approval_status', '')
        vuln_type = vuln.get('vuln_type')
        if current_approval_status != 'PENDING' or \
           get_last_approved_status(vuln):
            total_vulnerabilities[vuln_type][current_state].append(vuln)
        else:
            # vuln has pending approval_status
            pass

    for vuln_type in vuln_types:
        for vuln_state in vuln_states:
            vulns_grouped = group_specific(
                total_vulnerabilities[vuln_type][vuln_state], vuln_type)
            result_vulns.extend(vulns_grouped)
    return result_vulns


def format_vulnerabilities(vulnerabilities):
    """Format vulnerabilitites."""
    finding = {
        'ports': [],
        'lines': [],
        'inputs': []
    }
    vulns_types = ['ports', 'lines', 'inputs']
    vuln_values = {
        'ports': {
            'where': 'host',
            'specific': 'port',
        },
        'lines': {
            'where': 'path',
            'specific': 'line'
        },
        'inputs': {
            'where': 'url',
            'specific': 'field'
        }
    }
    for vuln in vulnerabilities:
        all_states = vuln.get('historic_state')
        current_state = all_states[len(all_states) - 1].get('state')
        vuln_type = vuln.get('vuln_type')
        if vuln_type in vulns_types:
            finding[vuln_type].append({
                vuln_values[vuln_type]['where']:
                    html.parser.HTMLParser().unescape(vuln.get('where')),
                vuln_values[vuln_type]['specific']:
                    html.parser.HTMLParser().unescape(vuln.get('specific')),
                'state': current_state
            })
        else:
            error_msg = 'Error: Vulnerability {vuln_id} of finding \
                {finding_id} does not have the right type'\
                .format(vuln_id=vuln.get('UUID'), finding_id=vuln.get('finding_id'))
            rollbar.report_message(error_msg, 'error')
    return finding


def get_vulnerabilities(finding_id):
    vulnerabilities = [vuln_utils.format_data(vuln)
                       for vuln in vuln_dal.get_vulnerabilities(finding_id)]

    return vulnerabilities


def list_vulnerabilities(finding_ids):
    """Retrieves all vulnerabilities for the requested findings"""
    vulns = []
    for finding_id in finding_ids:
        vulns += get_vulnerabilities(finding_id)

    return vulns


def get_last_approved_status(vuln):
    historic_state = vuln['historic_state']
    last_approved = ''
    for state in list(reversed(historic_state)):
        if state.get('approval_status') == 'APPROVED' or \
           not state.get('approval_status'):
            last_approved = state.get('state')
            break

    return last_approved


def get_current_state(vuln):
    last_approved = get_last_approved_status(vuln)
    if last_approved:
        state = last_approved
    else:
        state = vuln['historic_state'][-1].get('state')
    return state


def get_last_approved_analyst(vuln):
    historic_state = vuln['historic_state']
    last_analyst = ''
    for state in list(reversed(historic_state)):
        if state.get('approval_status') == 'APPROVED' or \
           not state.get('approval_status'):
            last_analyst = state.get('analyst', '')
            break

    return last_analyst


def get_last_approved_state(vuln):
    historic_state = vuln['historic_state']
    last_approved_state = {}
    for state in list(reversed(historic_state)):
        if state.get('approval_status') == 'APPROVED' or \
           not state.get('approval_status'):
            last_approved_state = state
            break

    return last_approved_state


def update_all_pending_vulns(finding_id, approval_status):
    list_vulns = get_vulnerabilities(finding_id)
    list_pending_vulns = \
        [vuln for vuln in list_vulns
         if vuln['historic_state'][-1].get('approval_status', '') == 'PENDING'
         ]
    return all([update_approval_status(
                finding_id, vuln['UUID'], approval_status)
                for vuln in list_pending_vulns])


def mask_vuln(finding_id, vuln_id):
    success = vuln_dal.update(finding_id, vuln_id, {
        'specific': 'Masked',
        'where': 'Masked'
    })

    return success


def delete_vulnerability(finding_id, vuln_id, justification, user_email):
    vulnerability = integrates_dal.get_vulnerability_dynamo(
        finding_id, uuid=vuln_id)
    success = False

    if vulnerability and vulnerability[0].get('historic_state'):
        all_states = vulnerability[0].get('historic_state')
        current_state = all_states[-1].get('state')
        if current_state == 'open':
            tzn = pytz.timezone(settings.TIME_ZONE)
            current_day = datetime.now(tz=tzn).today().strftime(
                '%Y-%m-%d %H:%M:%S')
            new_state = {
                'date': current_day,
                'state': 'DELETED',
                'justification': justification,
                'analyst': user_email}
            success = integrates_dal.update_state_dynamo(
                finding_id, vulnerability[0].get('UUID'), 'historic_state',
                [new_state], vulnerability)

    return success
